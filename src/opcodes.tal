
(
@|jumpTables )
@instrJumpTable
=do-NOP      =do-LDr16u16 =do-LDr16A  =do-INCr16  =do-INCr8    =do-DECr8    =do-LDr8u8 =do-RLCA
=do-LDu16SP  =do-ADDHLr16 =do-LDAr16  =do-DECr16  =do-INCr8    =do-DECr8    =do-LDr8u8 =do-RRCA
=do-STOP     =do-LDr16u16 =do-LDr16A  =do-INCr16  =do-INCr8    =do-DECr8    =do-LDr8u8 =do-RLA
=do-JR       =do-ADDHLr16 =do-LDAr16  =do-DECr16  =do-INCr8    =do-DECr8    =do-LDr8u8 =do-RRA
        
=do-JRc      =do-LDr16u16 =do-LDr16A  =do-INCr16  =do-INCr8    =do-DECr8    =do-LDr8u8 =do-DAA
=do-JRc      =do-ADDHLr16 =do-LDAr16  =do-DECr16  =do-INCr8    =do-DECr8    =do-LDr8u8 =do-CPL
=do-JRc      =do-LDr16u16 =do-LDr16A  =do-INCr16  =do-INCr8    =do-DECr8    =do-LDr8u8 =do-SCF
=do-JRc      =do-ADDHLr16 =do-LDAr16  =do-DECr16  =do-INCr8    =do-DECr8    =do-LDr8u8 =do-CCF
  
( TODO: Is it worth not using a table for these almost 64 instructions? )  
=do-LDr8r8   =do-LDr8r8   =do-LDr8r8  =do-LDr8r8  =do-LDr8r8   =do-LDr8r8   =do-LDr8r8 =do-LDr8r8
=do-LDr8r8   =do-LDr8r8   =do-LDr8r8  =do-LDr8r8  =do-LDr8r8   =do-LDr8r8   =do-LDr8r8 =do-LDr8r8
=do-LDr8r8   =do-LDr8r8   =do-LDr8r8  =do-LDr8r8  =do-LDr8r8   =do-LDr8r8   =do-LDr8r8 =do-LDr8r8
=do-LDr8r8   =do-LDr8r8   =do-LDr8r8  =do-LDr8r8  =do-LDr8r8   =do-LDr8r8   =do-LDr8r8 =do-LDr8r8
     
=do-LDr8r8   =do-LDr8r8   =do-LDr8r8  =do-LDr8r8  =do-LDr8r8   =do-LDr8r8   =do-LDr8r8 =do-LDr8r8
=do-LDr8r8   =do-LDr8r8   =do-LDr8r8  =do-LDr8r8  =do-LDr8r8   =do-LDr8r8   =do-LDr8r8 =do-LDr8r8
=do-LDr8r8   =do-LDr8r8   =do-LDr8r8  =do-LDr8r8  =do-LDr8r8   =do-LDr8r8   =do-HALT   =do-LDr8r8
=do-LDr8r8   =do-LDr8r8   =do-LDr8r8  =do-LDr8r8  =do-LDr8r8   =do-LDr8r8   =do-LDr8r8 =do-LDr8r8
  
=do-ADDr8    =do-ADDr8    =do-ADDr8   =do-ADDr8   =do-ADDr8    =do-ADDr8   =do-ADDr8   =do-ADDr8
=do-ADCr8    =do-ADCr8    =do-ADCr8   =do-ADCr8   =do-ADCr8    =do-ADCr8   =do-ADCr8   =do-ADCr8
=do-SUBr8    =do-SUBr8    =do-SUBr8   =do-SUBr8   =do-SUBr8    =do-SUBr8   =do-SUBr8   =do-SUBr8
=do-SBCr8    =do-SBCr8    =do-SBCr8   =do-SBCr8   =do-SBCr8    =do-SBCr8   =do-SBCr8   =do-SBCr8
  
=do-ANDr8    =do-ANDr8    =do-ANDr8   =do-ANDr8   =do-ANDr8    =do-ANDr8   =do-ANDr8   =do-ANDr8
=do-XORr8    =do-XORr8    =do-XORr8   =do-XORr8   =do-XORr8    =do-XORr8   =do-XORr8   =do-XORr8
=do-ORr8     =do-ORr8     =do-ORr8    =do-ORr8    =do-ORr8     =do-ORr8    =do-ORr8    =do-ORr8
=do-CPr8     =do-CPr8     =do-CPr8    =do-CPr8    =do-CPr8     =do-CPr8    =do-CPr8    =do-CPr8
 
=do-RETc     =do-POPr16   =do-JPcu16  =do-JPu16   =do-CALLcu16 =do-PUSHr16 =do-ADDu8   =do-RST
=do-RETc     =do-RET      =do-JPcu16  =do-INVALID =do-CALLcu16 =do-CALLu16 =do-ADCu8   =do-RST
=do-RETc     =do-POPr16   =do-JPcu16  =do-INVALID =do-CALLcu16 =do-PUSHr16 =do-SUBu8   =do-RST
=do-RETc     =do-RETI     =do-JPcu16  =do-INVALID =do-CALLcu16 =do-INVALID =do-SBCu8   =do-RST
 
=do-LDHu8A   =do-POPr16   =do-LDHCA   =do-INVALID =do-INVALID  =do-PUSHr16 =do-ANDu8   =do-RST
=do-ADDSPi8  =do-JPHL     =do-LDu16A  =do-INVALID =do-INVALID  =do-INVALID =do-XORu8   =do-RST
=do-LDHAu8   =do-POPr16   =do-LDHAC   =do-DI      =do-INVALID  =do-PUSHr16 =do-ORu8    =do-RST
=do-LDHLSPi8 =do-LDSPHL   =do-LDAu16  =do-EI      =do-INVALID  =do-INVALID =do-CPu8    =do-RST

@bitResSetJumpTable
=do-INVALID  =do-BIT      =do-RES      =do-SET

@shiftRotateJumpTable
=do-RLC      =do-RRC      =do-RL       =do-RR     =do-SLA      =do-SRA     =do-SWAP    =do-SRL

(
@|sm83utility )
@flag-mask [ 80 80 10 10 ] ( NZ Z NC C )
@flag-equals [ 00 80 00 10 ]

@TACShiftLookup [ $4 ( pad front of table to 'ignore' timer enable bit, to speed up table seek ) ]
                [ 02 40 20 00 ]

@pushShort ( low high -- )
  ;reg8/SPhigh STH2k LDA2 ( read stack pointer )
  #0001 SUB2 ( decrement SP )
  STAk ( write high byte )
  #0001 SUB2 ( decrement SP )
  ROT POP ( discard high byte )
  STAk ( write low byte )
  STH2r STA2 ( store new SP )
  POP ( discard low byte )
  TICK2 ( extra ticks for 2 writes )
JMP2r

@check-flag ( condition -- flag-equal )
  ( TODO: There HAS to be a faster way to check if one of two bits is set or not... find it! )
  STH2k ( duplicate offset on rst )
  ;flag-mask ADD2 LDA ( get flag mask for our flag )
  ;reg8/F LDA ( get current flags )
  AND ( and flag and mask byte )
  STH2r ( recover flag offset )
  ;flag-equals ADD2 LDA ( get flag equals byte )
  EQU ( compare masked flag byte to flag equals byte )
JMP2r

(
@|sm83opcodes )

@do-JPcu16 ( instr -- instr )
  DUP #18 AND #03 SFT #00 SWP ( setup flag offset on wst )
  ,check-flag JSR
  ,&flag-match JCN READ16PC ( advance PC past u16 ) POP2 ( discard u16 ) JMP2r &flag-match
  ( fall through to do-JPu16 )

@do-JPu16 ( instr -- instr )
  READ16PC
  ;PC STA2
  TICK ( extra tick )
JMP2r

@do-JRc ( instr -- instr )
  DUP #18 AND #03 SFT #00 SWP ( setup flag offset on wst )
  ,check-flag JSR
  ,&flag-match JCN READ8PC ( advance PC past u8 ) POP ( discard u8 ) JMP2r &flag-match
  ( fall through to JR )

@do-JR ( instr -- instr )
  READ8PC ( read u8 )
  #ff OVR #07 SFT ,&negative JCN POP #00 &negative SWP ( sign extension )
  ;PC LDA2 ( read current PC )
  ADD2 ( add offset )
  ;PC STA2 ( store new PC )
  TICK ( extra tick )
JMP2r

@do-CALLcu16 ( instr -- instr )
  DUP #18 AND #03 SFT #00 SWP ( setup flag offset on wst )
  ;check-flag JSR2
  ,&flag-match JCN READ16PC ( advance PC past u16 ) POP2 ( discard u16 ) JMP2r &flag-match
  ( fall through to do-CALLu16 )

@do-CALLu16 ( instr -- instr )
  READ16PC
  ;PC LDA2 SWP
  ;pushShort JSR2
  ;PC STA2
  TICK ( extra tick )
JMP2r

@do-JPHL ( instr -- instr )
  ;reg8/H LDA2
  ;PC STA2
JMP2r

@do-RST ( instr -- instr )
  ;PC LDA2 SWP
  ;pushShort JSR2
  DUP #38 AND #00 SWP
  ;PC STA2
  TICK ( extra tick )
JMP2r

@do-RETc ( instr -- instr )
  DUP #18 AND #03 SFT #00 SWP ( setup flag offset on wst )
  ;check-flag JSR2
  TICK ( extra tick )
  ,&flag-match JCN JMP2r &flag-match
  ( fall through to RET )

@do-RET ( instr -- instr )
  POPSHORT
  ;PC STA2
  TICK ( extra tick )
JMP2r

@do-RETI ( instr -- instr )
  POPSHORT
  ;PC STA2
  TICK
  ;do-EI JMP2

@do-LDr16u16 ( instr -- instr )
  GET-R16-GROUP1-ADDR STH2
  [ ;PC LDA2k INC2k INC2 ROT2 STA2 ] LDA2 ( read u16 )
  SWP ( swap high/low bytes from ROM for storage in r16 )
  STH2r STA2 ( store in r16 )
  TICK2
JMP2r

@do-ADDHLr16 ( instr -- instr )
  GET-R16-GROUP1-ADDR
  LDA2 ( read r16 value )
  ;reg8/H LDA2 ( get HL value )
  ADD2k
  DUP2 ;reg8/H STA2 ( store new value )

  GTH2k STH ( if sum is less than the HL arg, we carried, stash to rst )
  POP2 ( pop off sum )

  #0fff AND2 ( get lower 12 bits of r16 )
  OVR2 #0fff AND2 ( get lower 12 bits of HL )
  ADD2 #0fff GTH2 STH ( stash H to rst )
  POP2 ( pop off r16 value )

  ;reg8/F LDAk
  #80 AND ( retain z )
  STHr #50 SFT ORA ( h )
  STHr #40 SFT ORA ( c )
  ROT ROT STA ( - 0 h c )

  TICK ( extra tick )
JMP2r

@do-LDr8u8 ( instr -- instr )
  DUP #38 AND #03 SFT GET-R8-ADDR STH2 ( stash target addr )
  READ8PC ( read u8 )
  STH2r ;write8 ( .. ) ( recover target addr and write value )
JMP2

@do-LDr8r8 ( instr -- instr )
  DUP #38 AND #03 SFT GET-R8-ADDR STH2 ( stash target addr )
  DUP #07 AND GET-R8-ADDR_2
  LDA ( read source r8 )
  STH2r ;write8 ( .. ) ( recover target addr and write value )
JMP2

@do-LDSPHL ( instr -- instr )
  ;reg8/H LDA2
  ;reg8/SPhigh STA2
  TICK ( extra tick )
JMP2r

@do-LDu16A ( instr -- instr )
  ;reg8/A LDA ( read A )
  READ16PC ( read u16 )
  ;write8 JSR2 ( store in RAM )
  TICK ( extra tick )
JMP2r

@do-LDAu16 ( instr -- instr )
  READ16PC ( read u16 )
  LDA ( read from RAM )
  ;reg8/A STA ( store in A )
  TICK ( extra tick )
JMP2r

@do-LDHu8A ( instr -- instr )
  ;reg8/A LDA ( read A )
  #ff READ8PC ( $FF00 + read u8 )
  ;write8 JSR2 ( store in HRAM )
  TICK ( extra tick )
JMP2r

@do-LDHAu8 ( instr -- instr )
  #ff READ8PC ( $FF00 + read u8 )
  LDA ( read from HRAM )
  ;reg8/A STA ( store in A )
  TICK ( extra tick )
JMP2r

@do-LDHCA ( instr -- instr )
  ;reg8/A LDA ( read A )
  #ff ;reg8/C LDA ( $FF00 + read C )
  ;write8 JSR2 ( store in HRAM )
  TICK ( extra tick )
JMP2r

@do-LDHAC ( instr -- instr )
  #ff ;reg8/C LDA ( $FF00 + read C )
  LDA ( read from HRAM )
  ;reg8/A STA ( store in A )
  TICK ( extra tick )
JMP2r

@do-LDAr16 ( instr -- instr )
  ( Note: The [r16] source options are: [bc], [de], [hli], [hld] )
  DUP #30 AND #03 SFT STHk
    [ DUP #06 NEQ ,&notHLD JCN POP #04 &notHLD ] ( change HLD case to use HL as r16, change %11 to %10 )
    #00 SWP ;reg8 ADD2 ( get addr of source r16 from instruction )
  LDA2 ( read address stored in r16 )

  LDA ( read value from [r16] )
  ;reg8/A STA ( store in A )

  &hlihld
  TICK ( extra tick )

  ( check for hli/hld )
  STHr ( recover r16 argument )
  DUP #04 EQU ,&hli JCN
      #06 EQU ,&hld JCN
  JMP2r
  &hli POP ;reg8/H LDA2k INC2 SWP2 STA2 JMP2r
  &hld ;reg8/H LDA2k #0001 SUB2 SWP2 STA2 JMP2r

@do-LDr16A ( instr -- instr )
  ( Note: The [r16] source options are: [bc], [de], [hli], [hld] )

  DUP #30 AND #03 SFT STHk
    [ DUP #06 NEQ ,&notHLD JCN POP #04 &notHLD ] ( change HLD case to use HL as r16, change %11 to %10 )
    #00 SWP ;reg8 ADD2 ( get addr of source r16 from instruction )
  LDA2 ( read address stored in r16 )
  
  ;reg8/A LDA ( read A )
  ROT ROT ( swap value/addr )
  ;write8 JSR2 ( store in [r16] )

  ,do-LDAr16/hlihld JMP

@do-LDu16SP ( instr -- instr )
  ;reg8/SPhigh LDA2 ( read SP )
  READ16PC ( read u16 )
  STH2k ( copy destination to rst )
  ;write8 JSR2 ( write low byte )
  STH2r INC2 ( recover desintation, increment )
  ;write8 JSR2 ( write high byte )
  TICK2 ( extra ticks )
JMP2r

@do-ADDSPi8 ( instr -- instr )
  ( Note: Test 03 is useful for verifying this )
  READ8PC ( read u8 )
  #ff OVR #07 SFT ,&negative JCN POP #00 &negative SWP ( sign extension )
  ;reg8/SPhigh LDA2 ( read current SP )
  ADD2k ( SP + i8 )
  ;reg8/SPhigh STA2 ( store new SP )

  TICK ( extra tick )

  &complete
  #00ff AND2 ( get lower byte of SP )
  OVR2 #00ff AND2 ( get lower byte of i8 )
  ADD2k #00ff GTH2 STH ( stash C to rst )
  NIP ( remove high byte of i8 )
  #0f AND ( get lower nibble of i8 )
  OVR #0f AND ( get lower nibble of SP )
  ADD #0f GTH STH ( stash H to rst )

  POP2 POP2 ( cleanup stack, TODO: Can we consume these earlier? )

  STHr #50 SFT ( h )
  STHr #40 SFT ORA ( c )
  ;reg8/F STA ( 0 0 h c mask )

  TICK ( extra tick )
JMP2r

@do-LDHLSPi8 ( instr -- instr )
  ;reg8/SPhigh LDA2 ( read SP )
  READ8PC ( read i8 )
  #ff OVR #07 SFT ,&negative JCN POP #00 &negative SWP ( sign extension )
  ADD2k ( SP + i8 )
  ;reg8/H STA2 ( store result in HL )

  ,do-ADDSPi8/complete JMP

@do-INCr8 ( instr -- instr )
  DUP #38 AND #03 SFT GETSET-R8-ADDR
  LDAk [ STHk ] INC STHk ROT ROT
  ;write8 JSR2

  ;reg8/F LDAk ( load old flags )
  #10 AND ( retain old carry flag )
  STHr ( recover new register value )
  #00 EQU #70 SFT ORA ( z flag )
  STHr #0f AND #0f EQU ( recover pre-inc lower nibble, set h if it was 15 )
  #50 SFT ORA ( h flag )
  ROT ROT STA ( z 0 h - )
JMP2r

@do-DECr8 ( instr -- instr )
  DUP #38 AND #03 SFT GETSET-R8-ADDR
  LDAk [ STHk ] #01 SUB STHk ROT ROT ;write8 JSR2

  ;reg8/F LDAk
  #10 AND ( retain c )
  STHr ( recover new value )
  #00 EQU #70 SFT ORA ( z )
  #40 ORA ( n )
  STHr #0f AND #00 EQU #50 SFT ( recover pre-inc lower nibble, set h if it was 0 )
  ORA ( h )
  ROT ROT STA ( z 1 h - )
JMP2r

@do-INCr16 ( instr -- instr )
  GET-R16-GROUP1-ADDR
  LDA2k INC2 SWP2 STA2 ( read value, increment, store )
  TICK ( extra tick )
JMP2r

@do-DECr16 ( instr -- instr )
  GET-R16-GROUP1-ADDR
  LDA2k #0001 SUB2 SWP2 STA2 ( read value, decrement, store )
  TICK ( extra tick )
JMP2r

@do-PUSHr16 ( instr -- instr )
  DUP #30 AND #03 SFT STHk ( stash to rst )
  #00 SWP
  ;reg8 ADD2 ( add base and offset to get addr )
  LDA2 ( read register pair value )

  STHr ( recover r16 bit pair )
  #06 EQU ,&AF JCN [ SWP ] &AF ( swap high/low bytes, except for AF )

  ;pushShort JSR2

  TICK ( extra tick )
JMP2r

@do-POPr16 ( instr -- instr )
  DUP #30 AND #03 SFT STHk ( stash to rst )
  #00 SWP
  ;reg8 ADD2 ( add base and offset to get addr )

  POPSHORT

  STHr ( recover r16 bits )
  #06 NEQ ,&notAF JCN [ SWP ] #f0ff AND2 &notAF ( swap high/low bytes back for AF, and mask low nibble of F )

  SWP2 ( swap r16 addr and short )
  STA2 ( write popped value to r16 )
JMP2r

@do-DI ( instr -- instr )
  #00 ;IME STA
JMP2r

@do-EI ( instr -- instr )
  #1f ;IME STA ( Note: Enabled with 1f to allow easy ANDing together with IF/IE flags )
JMP2r

@do-STOP
  ,do-STOP JMP

@do-ADDu8 ( instr -- instr )
  READ8PC ( read u8 )
  ,do-ADDr8/do-ADD JMP

@do-ADDr8 ( instr -- instr )
  DUP #07 AND GET-R8-ADDR LDA ( get source of compare from instruction )
&do-ADD
  #00 SWP ( convert arg to short )
  #00 ;reg8/A LDA ( read A as short )
  ADD2k ( add as short to detect carry )

  ( wst: argShort AShort resultShort )
  DUP ;reg8/A STA ( store result in A )
  #00 EQU #70 SFT ( z )
  SWP #40 SFT ( c, using high byte overflow )
  ORA STH ( stash z|c )
  #0f AND NIP OVR #0f AND ( get lower nibble of both inputs )
  ADD #0f GTH #50 SFT ( h )
  STHr ORA ( recover z|c, OR with h )
  ;reg8/F STA ( z 0 h c )
  POP2

JMP2r

@do-ADCu8 ( instr -- instr )
  READ8PC ( read u8 )
  ,do-ADCr8/do-ADC JMP

@do-ADCr8 ( instr -- instr )
  DUP #07 AND GET-R8-ADDR LDA ( get source of compare from instruction )
&do-ADC
  #00 SWP ( convert arg to short )
  #00 ;reg8/A LDA ( read A as short )
  LITr 00 ;reg8/F LDA #10 AND #04 SFT STH ( get current carry value as boolean, on rst )
  ADD2k ( add arg+A, keep inputs ) STH2kr ( recover carry from rst ) ADD2 ( add carry to result )
  
  ( rst: oldCarryShort )
  ( wst: argShort AShort resultShort )
  DUP ;reg8/A STA ( store result in A )
  #00 EQU #70 SFT ( z )
  SWP #40 SFT ( c )
  ORA STH ( stash z|c )
  #0f AND NIP OVR #0f AND ( get lower nibble of both inputs )
  ROTr ROTr STHr POPr ( get old carry from rst )
  ADD ADD #0f GTH #50 SFT ( h )
  STHr ORA ( recover z|c, OR with h )
  ;reg8/F STA ( z 0 h c )
  POP2

JMP2r

@do-SUBu8 ( instr -- instr )
  READ8PC ( read u8 )
  ,do-SUBr8/do-SUB JMP

@do-SUBr8 ( instr -- instr )
  DUP #07 AND GET-R8-ADDR LDA ( get source of compare from instruction )
&do-SUB
  ;reg8/A LDA ( read A )
  SWP ( swap r8/u8 and A for correct subtraction order )
  SUBk

  ;reg8/A STA ( store result in A )
  LTHk #40 SFT STH ( c to rst )
  DUP2 SWP ( duplicate/swap inputs for half carry calculation )
  #0f AND OVR #0f AND ( get lower nibble of both inputs )
  SUB #10 GTH #50 SFT STH POP ( h to rst )
  ORAr ( c|h )
  EQU #70 SFT ( z )
  #40 ( n )
  STHr ORA ORA
  ;reg8/F STA ( z 1 h c )
JMP2r

@do-SBCu8 ( instr -- instr )
  READ8PC ( read u8 )
  ,do-SBCr8/do-SBC JMP

@do-SBCr8 ( instr -- instr )
  DUP #07 AND GET-R8-ADDR LDA ( get source of compare from instruction )
&do-SBC
  #00 SWP ( convert arg to short )
  #00 ;reg8/A LDA ( read A as short )
  SWP2 ( swap r8/u8 and A for correct subtraction order )
  LITr 00 ;reg8/F LDA #10 AND #04 SFT STH ( get current carry value as boolean, on rst )
  SUB2k ( A-arg, keep inputs ) STH2kr ( get carry from rst ) SUB2 ( subtract carry )

  ( rst: oldCarryShort )
  ( wst: argShort AShort resultShort )
  DUP ;reg8/A STA ( store result in A )
  #00 EQU #70 SFT ( z )
  SWP #00 NEQ #40 SFT ( c )
  ORA STH ( stash z|c )
  #0f AND NIP OVR #0f AND ( get lower nibble of both inputs )
  SWP SUB ( swap from arg/A to A/arg for correct sub order )
  ROTr ROTr STHr POPr ( get old carry from rst )
  SUB #0f GTH #50 SFT ( h )
  STHr ORA ( z|c|h )
  #40 ( n )
  ORA
  ;reg8/F STA ( z 1 h c )
  POP2
JMP2r

@do-CPu8 ( instr -- instr )
  READ8PC ( read u8 )
  ,do-CPr8/do-CP JMP

@do-CPr8 ( instr -- instr )
  DUP #07 AND GET-R8-ADDR LDA ( get source of compare from instruction )
&do-CP
  ;reg8/A LDA ( read A )
  SWP ( swap r8/u8 and A for correct 'subtraction' order )

  LTHk #40 SFT STH ( c to rst )
  DUP2 SWP ( duplicate/swap inputs for half carry calculation )
  #0f AND OVR #0f AND ( get lower nibble of both inputs )
  SUB #10 GTH #50 SFT STH POP ( h to rst )
  ORAr ( c|h )
  EQU #70 SFT ( z )
  #40 ( n )
  STHr ORA ORA
  ;reg8/F STA ( z 1 h c )
JMP2r

@do-ANDu8 ( instr -- instr )
  READ8PC ( read u8 )
  ,do-ANDr8/do-AND JMP

@do-ANDr8 ( instr -- instr )
  DUP #07 AND GET-R8-ADDR LDA
&do-AND
  ;reg8/A LDA ( read A )
  AND

  DUP ;reg8/A STA ( store A )
  #00 EQU #70 SFT ( z )
  #20 ORA ( h )
  ;reg8/F STA ( z 0 1 0 )
JMP2r

@do-XORu8 ( instr -- instr )
  READ8PC ( read u8 )
  ,do-XORr8/do-XOR JMP

@do-XORr8 ( instr -- instr )
  DUP #07 AND GET-R8-ADDR LDA
&do-XOR
  ;reg8/A LDA ( read A )
  EOR
&cleanup
  DUP ;reg8/A STA ( store A )
  #00 EQU #70 SFT ( z )
  ;reg8/F STA ( z 0 0 0 )
JMP2r

@do-ORu8 ( instr -- instr )
  READ8PC ( read u8 )
  ,do-ORr8/do-OR JMP

@do-ORr8 ( instr -- instr )
  DUP #07 AND GET-R8-ADDR LDA
&do-OR
  ;reg8/A LDA ( read A )
  ORA
  ,do-XORr8/cleanup JMP

@do-RRA ( instr -- instr )
  ;reg8/A LDAk ( read A value )
  #0001 SFT2 ( shift into low byte )
  STH ( move low byte to rst )
  ;reg8/F LDA #10 AND #30 SFT ( get carry flag in bit 7 )
  ORA ( OR carry flag into bit 7 )
  ROT ROT STA ( store new value in A )

  STHr #03 SFT ( recover low byte from rst, c )
  ;reg8/F STA ( 0 0 0 c )
JMP2r

@do-RRCA ( instr -- instr )
  ;reg8/A LDAk ( read A value )
  #0001 SFT2 ( shift into low byte )
  STHk ( copy low byte to rst )
  ORA ( OR shifted out bit 0 onto bit 7 )
  ROT ROT STA ( store new value in A )

  STHr #03 SFT ( recover low byte from rst, c )
  ;reg8/F STA ( 0 0 0 c )
JMP2r

@do-RLCA ( instr -- instr )
  ;reg8/A LDAk ( read A value )
  #00 SWP ( convert to short )
  #10 SFT2 ( shift into high byte )
  OVR STH ( copy high byte and move to rst )
  ORA ( AND ) ( OR low/high bytes to put bit 7 into bit 0 )
  ROT ROT STA ( store new value in A )

  STHr #40 SFT ( c )
  ;reg8/F STA ( 0 0 0 c )
JMP2r

@do-RLA ( instr -- instr )
  ;reg8/A LDAk ( read r8 value )
  #00 SWP ( convert to short )
  #10 SFT2 ( shift into high byte )
  SWP STH ( move high byte to rst )
  ;reg8/F LDA #10 AND #04 SFT ( get carry flag in bit 0 )
  ORA ( OR carry flag into bit 0 )
  ROT ROT STA ( store new value in A )

  STHr #40 SFT ( c )
  ;reg8/F STA ( 0 0 0 c )
JMP2r

@do-DAA ( instr -- instr )
  ;reg8/F LDAk ( read flags )
  STH ( move to rst )
  INC2 ( advance addr to A )
  LDA ( read A )
  DUPr LITr 40 ANDr LITr 00 NEQr LITr _&afterSubtraction JCNr ( check N )
    ( after addition )
    DUPr LITr 10 ANDr LITr 00 NEQr LITr _&addOutOfBounds JCNr
    DUP #9a LTH ,&addCheckH JCN
    &addOutOfBounds
      #60 ADD ( A += $60 )
      ;reg8/F LDAk #10 ORA ROT ROT STA ( set carry flag direct )
    &addCheckH
    DUPr LITr 20 ANDr LITr 00 NEQr LITr _&addHalfCarry JCNr
    DUP #0f AND #0a LTH ,&cleanup JCN
    &addHalfCarry
      #06 ADD ( A += $06 )
  ,&cleanup JMP
  &afterSubtraction
    DUPr LITr 10 ANDr LITr 00 EQUr LITr _&subCheckH JCNr
      #60 SUB ( A -= $60 )
    &subCheckH
    DUPr LITr 20 ANDr LITr 00 EQUr LITr _&cleanup JCNr
      #06 SUB ( A -= $06 )

  &cleanup
  POPr ( cleanup rst )

  DUP ;reg8/A STA ( store new A )
  #00 EQU #70 SFT STH ( z )
  ;reg8/F LDAk
  #50 AND ( retain n, c )
  STHr ORA
  ROT ROT STA ( z - 0 - , carry set earlier )
JMP2r

@do-CPL ( instr -- instr )
  ;reg8/A LDAk ( read r8 value )
  #ff EOR ( cpl )
  ROT ROT STA ( store new value in A )

  ;reg8/F LDAk
  #90 AND ( retain z c )
  #60 ORA ( set h n )
  ROT ROT STA ( - 1 1 - )
JMP2r

@do-SCF ( instr -- instr )
  ;reg8/F LDAk
  #80 AND ( get prior Z flag )
  #10 ORA ( set carry flag )
  ROT ROT STA ( store new flags )
JMP2r

@do-CCF ( instr -- instr )
  ;reg8/F LDAk
  #10 EOR ( invert carry flag )
  #90 AND ( clear N H flags )
  ROT ROT STA ( store new flags )
JMP2r

@do-BIT ( instr -- instr )
  #01 ( initial bitmask )
  OVR #38 AND #10 SFT ( get shift count for bitmask )
  SFT ( shift initial bitmask by shift count )
  OVR #07 AND GET-R8-ADDR ( get r8 )
  LDA ( read r8 value )
  AND ( AND with bitmask to check bit )

  #00 EQU #70 SFT STH ( z )
  ;reg8/F LDAk
  #10 AND ( retain c )
  STHr ORA ( c|z )
  #20 ORA ( h )
  ROT ROT STA ( z 0 1 - )
JMP2r

@do-RES ( instr -- instr )
  #01 ( initial bitmask )
  OVR #38 AND #10 SFT ( get shift count for bitmask )
  SFT ( shift initial bitmask by shift count )
  #ff EOR ( invert bitmask )
  OVR #07 AND GETSET-R8-ADDR ( get r8 )
  STH2 ( move addr to rst )
  LDAkr ( read r8 value onto rst )
  STHr ( move value to wst )
  AND ( AND with inverted mask to clear bit )
  STH2r ( get addr from rst )
  ;write8 ( .. ) ( store new value )
JMP2

@do-SET ( instr -- instr )
  #01 ( initial bitmask )
  OVR #38 AND #10 SFT ( get shift count for bitmask )
  SFT ( shift initial bitmask by shift count )
  OVR #07 AND GETSET-R8-ADDR ( get r8 )
  STH2 ( move addr to rst )
  LDAkr ( read r8 value onto rst )
  STHr ( move value to wst )
  ORA ( ORA with mask to set bit )
  STH2r ( get addr from rst )
  ;write8 ( .. ) ( store new value )
JMP2

@do-RLC ( instr -- instr )
  DUP #07 AND GETSET-R8-ADDR ( get r8 )
  LDAk ( read r8 value )
  #00 SWP ( convert to short )
  #10 SFT2 ( shift into high byte )
  OVR STH ( copy high byte and move to rst )
  ORA ( OR low/high bytes to put bit 7 into bit 0 )
  STHk ( copy result to rst )
  ROT ROT ;write8 JSR2 ( store new value in r8 )

  STHr ( recover value from rst )
  #00 EQU #70 SFT ( z )
  STHr #40 SFT ORA ( c )
  ;reg8/F STA ( z 0 0 c )
JMP2r

@do-RRC ( instr -- instr )
  DUP #07 AND GETSET-R8-ADDR ( get r8 )
  LDAk ( read r8 value )
  #0001 SFT2 ( shift into low byte )
  STHk ( copy low byte to rst )
  ORA ( OR shifted bit 0 onto bit 7 )
  STHk ( copy result to rst )
  ROT ROT ;write8 JSR2 ( store new value in r8 )

  STHr ( recover value from rst )
  #00 EQU #70 SFT ( z )
  STHr #03 SFT ORA ( c )
  ;reg8/F STA ( z 0 0 c )
JMP2r

@do-RL ( instr -- instr )
  DUP #07 AND GETSET-R8-ADDR ( get r8 )
  LDAk ( read r8 value )
  #00 SWP ( convert to short )
  #10 SFT2 ( shift into high byte )
  SWP STH ( move high byte to rst )
  ;reg8/F LDA #10 AND #04 SFT ( get carry flag in bit 0 )
  ORA ( OR carry flag into bit 0 )
  STHk ( copy result to rst )
  ROT ROT ;write8 JSR2 ( store new value in r8 )

  STHr ( recover value from rst )
  #00 EQU #70 SFT ( z )
  STHr #40 SFT ORA ( c )
  ;reg8/F STA ( z 0 0 c )
JMP2r

@do-RR ( instr -- instr )
  DUP #07 AND GETSET-R8-ADDR ( get r8 )
  LDAk ( read r8 value )
  #0001 SFT2 ( shift into low byte )
  STH ( move low byte to rst )
  ;reg8/F LDA #10 AND #30 SFT ( get carry flag in bit 7 )
  ORA ( OR carry flag into bit 7 )
  STHk ( copy result to rst )
  ROT ROT ;write8 JSR2 ( store new value in r8 )

  STHr ( recover value from rst )
  #00 EQU #70 SFT ( z )
  STHr #03 SFT ORA ( c )
  ;reg8/F STA ( z 0 0 c )
JMP2r

@do-SLA ( instr -- instr )
  DUP #07 AND GETSET-R8-ADDR ( get r8 )
  LDAk ( read r8 value )
  #00 SWP ( convert to short )
  #10 SFT2 ( shift into high byte )
  STH2k ( copy short to rst )
  NIP ( discard high byte )
  ROT ROT ;write8 JSR2 ( store new value in r8 )

  STHr ( recover value from rst )
  #00 EQU #70 SFT ( z )
  STHr #40 SFT ORA ( c )
  ;reg8/F STA ( z 0 0 c )
JMP2r

@do-SRA ( instr -- instr )
  DUP #07 AND GETSET-R8-ADDR ( get r8 )
  LDAk ( read r8 value )
  STHk ( copy value to rst )
  LITr 80 ANDr ( mask down to bit on rst )
  #0001 SFT2 ( shift into low byte )
  STHr ( recover bit 7 )
  SWP
  STH ( move low byte to rst )
  ORA ( OR value and bit7 together )
  STHk ( copy result to rst )
  ROT ROT ;write8 JSR2 ( store new value in r8 )

  STHr ( recover value from rst )
  #00 EQU #70 SFT ( z )
  STHr #03 SFT ORA ( c )
  ;reg8/F STA ( z 0 0 c )
JMP2r

@do-SWAP ( instr -- instr )
  DUP #07 AND GETSET-R8-ADDR ( get r8 )
  LDAk ( read r8 value )
  DUP #04 SFT ( get new low nibble )
  SWP
  #40 SFT ( get new high nibble )
  ORA ( combine nibbles )
  STHk ROT ROT ;write8 JSR2 ( store new value in r8 )
  STHr
  #00 EQU #70 SFT ( Z flag )
  ;reg8/F STA ( z 0 0 0 )
JMP2r

@do-SRL ( instr -- instr )
  DUP #07 AND GETSET-R8-ADDR ( get r8 )
  LDAk ( read r8 value )
  #0001 SFT2 ( shift into low byte )
  STH ( move low byte to rst )
  STHk ( copy result to rst )
  ROT ROT ;write8 JSR2 ( store new value in r8 )
  STHr ( recover value from rst )
  #00 EQU #70 SFT ( z )
  STHr #03 SFT ORA ( c )
  ;reg8/F STA ( z 0 0 c )
JMP2r

@do-NOP ( instr -- instr )
JMP2r

@do-HALT ( instr -- instr )
  #01 ;halt STA
JMP2r

@do-INVALID ( instr -- instr )
  ;msg-invalidInstruction ;pstr JSR2
  HALT

@msg-invalidInstruction
  "Invalid 20 "Instruction $1
