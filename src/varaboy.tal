( varaboy.tal )

(
@|devices )
|00 @System     [ &vector $2 &pad $6 &r $2 &g $2 &b $2 &debug $1 &state $1 ]
|10 @Console    [ &vector $2 &read $1 &pad $5 &write $1 &error $1 ]
|20 @Screen     [ &vector $2 &width $2 &height $2 &auto $1 &pad $1 &x $2 &y $2 &addr $2 &pixel $1 &sprite $1 ]
|80 @Controller [ &vector $2 &button  $1 &key $1 ]
|90 @Mouse      [ &vector $2 &x $2 &y $2 &state $1 &pad $3 &scrollx $2 &scrolly $2 ]
|a0 @File0      [ &vector $2 &success $2 &stat $2 &delete $1 &append $1 &name $2 &length $2 &read $2 &write $2 ]
|b0 @File1      [ &vector $2 &success $2 &stat $2 &delete $1 &append $1 &name $2 &length $2 &read $2 &write $2 ]

(
@|macros )
%EMIT { .Console/write DEO }
%HALT { #01 .System/state DEO }
%DBG { #01 .System/debug DEO }

( stdin vs hardcoded filepath )
%READFILE { ;on-console .Console/vector DEO2 }
%xREADFILE { ;default-gb ;filepath ;scpy JSR2 ;start JMP2 } ( Note: Switch to this READFILE when using uxn32 to debug )

( release macros )
%INIT { ;on-frame .Screen/vector DEO2 ;on-button .Controller/vector DEO2 }
%VBLANK { POP2 POP2 BRK }
%PRINTSTATE { }

( cli debug macros )
( Note: Switch to this set of macros when using uxncli to dump register trace logs )
%xINIT { ;on-frame JMP2 }
%xVBLANK { ,&afterModeChange JMP }
%xPRINTSTATE { ;print-state JSR2 }

(
@|opcodeMacros )
%READ8PC { TICK [ ;PC LDA2k INC2k ROT2 STA2 ] LDA }
( TODO: binji notes that it's necessary to read8/pc++, then read8/pc++ again to avoid undefined behaviour. Do that? )
%READ16 { [ LDA2k INC2k INC2 ROT2 STA2 ] LDA2 SWP TICK2 }
%READ16PC { ;PC READ16 }
%GET-R8-ADDR { [ DUP #06 NEQ ,&simpleR8 JCN [ POP ;reg8/H LDA2 TICK ] ] ,&r8ready JMP &simpleR8 #00 SWP ;reg8 ADD2 &r8ready }
%GET-R8-ADDR_2 { [ DUP #06 NEQ ,&simpleR8_2 JCN [ POP ;reg8/H LDA2 TICK ] ] ,&r8ready_2 JMP &simpleR8_2 #00 SWP ;reg8 ADD2 &r8ready_2 } ( simple duplicate to allow second use in same instr handler )
%GETSET-R8-ADDR { [ DUP #06 NEQ ,&simpleR8 JCN [ POP ;reg8/H LDA2 TICK2 ] ] ,&r8ready JMP &simpleR8 #00 SWP ;reg8 ADD2 &r8ready } ( tick twice since [HL] will be written )
%GET-R16-GROUP1-ADDR { DUP #30 AND #03 SFT [ DUP #06 NEQ ,&notSP JCN INC INC &notSP ] #00 SWP ;reg8 ADD2 }
%TICK { ;cycles LDA2k #0004 ADD2 SWP2 STA2 }
%TICK2 { ;cycles LDA2k #0008 ADD2 SWP2 STA2 }
%POPSHORT { ;reg8/SPhigh READ16 }
%CHECK-FLAG { DUP #e018 ROT AND LDA2 ;reg8/F LDA AND EQU }

~src/mmap.tal

( Note: Only code/data in the e000-fdff range is "safe" during runtime. Code/data here
  must only be used for startup, or copied to the safe region for use during runtime. )
|0100
  ( meta )
  ;meta #f0 DEO2

  ( theme )
  #fc40 .System/r DEO2
  #fc40 .System/g DEO2
  #fc40 .System/b DEO2
  ;load-theme JSR2

	( size )
  #00a0 .Screen/width DEO2
  #0090 .Screen/height DEO2

  ( TODO: find a way to automatically load a default ROM if none is provided on the command line )
  READFILE
BRK

@on-console ( -> )

  ;filepath STH2
  ( read source )
  .Console/read DEI
  DUP #20 LTH OVR #7f GTH ORA ,&end JCN
  STH2kr ;slen JSR2 #003f GTH2 ,&end JCN
    STH2r ;sput JSR2 BRK
    &end
  POP

  STH2r ;start JSR2

BRK

@start ( src* -- )

  ( build .sav version of filename for SRAM, even if not battery backed )
  ;filepath ;savepath STH2k ;scpy JSR2 ( copy filepath to savepath )
  ;saveExtension ( source for .sav extension )
  STH2kr ;slen JSR2 #02 SUB STH2kr ADD2 ( get addr of start of extension, assuming 2 letter (gb) extension )
  ;scpy JSR2 ( copy sav extension over gb )
  STH2r .File1/name DEO2

  ( Detect MBC type and copy handler to @MBCHandler )
  ;filepath .File0/name DEO2
	#0150 .File0/length DEO2 ( read header to romx for inspection )
	;romx .File0/read DEO2
  #0000 .File0/name DEO2 ( close file to reset addr )

  #00 ;header/ramSize LDA
  ;SRAMBankCounts ADD2 LDA ( get number of SRAM banks )
  DUP #00 EQU ,&noSRAM JCN
    DUP ;SRAMBanks STA ( store for use during banking )
    #2000 .File1/length DEO2 ( SRAM banks are 8KB )
    ;sram .File1/read DEO2 ( attempt read from file )
    .File1/success DEI2 ORA ( check success value ) ,&saveFileExists JCN
      ( zero-fill SRAM file to full size )
      #00 ( counter )
      &SRAMFillLoop
        ;sram .File1/write DEO2
      INC GTHk ,&SRAMFillLoop JCN
      POP
    &saveFileExists
    ( If more than one bank is used, unpack each into a distinct file named _bankX.sav )
    ( Note: This is done so that each SRAM bank can be quickly dumped to disk during SRAM 
      bank swaps. The bank files are repacked on shutdown. )
    ;savepath .File1/name DEO2 ( Reset file seek location )
    DUP #01 EQU DUP ;isSingleRAMBank STA ,&singleBank JCN
      #2000 .File0/length DEO2 ( set length for writes to bank files )
      #00 ( counter )
      &unpackLoop
        DUP #41 ADD ( calculate ASCII value for bank number (A-P), hex would be nice but is harder to generate )
        ;bankPathDigit STA ( replace bank character in bankPath )
        ;bankPath .File0/name DEO2 ( set name for bank file )
        ;sram .File1/read DEO2k POP .File0/write DEO2 ( read from SAV file to memory, write out to bank file )
        #0000 .File0/name DEO2 ( close bank file )
      INC GTHk ,&unpackLoop JCN
      POP
      ;savepath .File1/name DEO2 ( Reset file seek location )
    &singleBank
    ( read SRAM file into SRAM, either single bank or initial multi-bank )
    ;sram .File1/read DEO2
  &noSRAM
  POP
  #0000 .File1/name DEO2 ( close SRAM file )

  #00 ;header/cartridgeType LDA
  DUP #1f GTH ,&unsupportedMBC JCN
  #10 SFT ;MBCHandlerLookup ADD2 LDA2 ( handler start address )
  ;MBCHandler ( destination addr )
  #0080 ( bytes to copy, divided by two )

  ( Just copy the max handler size regardless, as trailing data won't hurt )
  ( Thanks to d_m for this copy routine! )
  ( copies 2-byte pairs from src to dst )
  ( @copy2 ( src* dst* count* -> ) )
  #0000 SWP2 SUB2             ( src* dst* i* )
  STH2 SWP2                   ( dst* src* [i*] )
  &loop
      LDA2k ROT2              ( src* bb* dst* [i*] )
      STA2k NIP2 INC2 INC2 SWP2 INC2 INC2 INC2r   ( dst* src* [i+1*] )
      ORAkr STHr ,&loop JCN   ( dst* src* [i+1*] )
  POP2 POP2 POP2r             ( )

  ( Initialize emulator state )
  #01 ;frameSkip STA ( Note: A value of 1 means no frameskip )
  #01 ;frameSkipCounter STA ( Must be 1 to draw the initial frame )
  
  ( Initialize CPU state )
  ( Note: It feels strange to do this before the ROM is loaded, but doing it here
    means we don't waste valuable safe address space on the code. )
  #91 ;io/rLCDC STA
  #ac00 ;io/rDIV STA2
  #01 ;io/rLY STA ( #00 is likely fine, tuned to better match Emulicious cpu_instrs tracelog )
  #e0 ;io/rIF STA ( IF is a 5 bit register, so the upper 3 bits must be set )

  #ff ;joypad STA ( default to all buttons unpressed )
  #ff #ff4d STA ( make KEY1 read #ff to workaround cpu_instrs test )

  #ff ;bgwinMaskedXOffset STA ( reset bgwinMaskedXOffset to ensure fresh data on the next scanline )

  ;varaboy JMP2 ( jump to program code )

&unsupportedMBC
  ;msg-unsupportedMBC ;pstr JSR2
  HALT

@msg-unsupportedMBC
  "Unsupported 20 "MBC $1

@meta =&end =appicon &body
  ( name ) "Varaboy $1
  ( version ) "Ver. 20 "1 $1
  ( details ) "A 20 "Game 20 "Boy 20 "Emulator $1
  ( author ) "Dave 20 "VanEe 20 7f 20 "2022 $1
  &end $1

~src/assets.tal
~src/mbcs.tal

(
@|varaboy )
( We jump from the uxn entry point $0100 to echo RAM, and operate the emulator from 
  entirely within echo RAM. This allows the Game Boy addresses to remain unmodified, I hope! )
|e000 ( ends at fdff, 1dff[7679] bytes )
( The flag table includes the mask and expected value for the 4 conditional instruction
  options. It's page aligned to speed up check-flag and spaced out so we can use the masked
  portion of the instructions directly without shifting. )
@flag-table [ 00 80 $6 80 80 $6 00 10 $6 10 10 ]

@varaboy
  
  ;filepath .File0/name DEO2
	#8000 .File0/length DEO2 ( read first 32KB directly to memory )
	;rom0 .File0/read DEO2
	( .File0/success DEI2 )
  #0000 .File0/name DEO2 ( close file to reset addr )

  #4000 .File0/length DEO2 ( setup for 8KB per ROM bank reads during runtime )

  ( Setup UXN Screen vector for release mode )
  ( Note: We execute up to the end of LY 143 for every frame vector. This should
    allow uxnemu to operate and also lock us to multiples of 60Hz. )
  INIT ( macro to swap modes for debug )
BRK

@on-button ( -- )

  ( keyboard controls )
  .Controller/key DEI
    [ #1b ] NEQk NIP ,&no-esc JCN
      ( Cleanup SRAM )
      ( Note: Not currently MBC-specific! )
      ;SRAMBanks LDA DUP #00 EQU ,&noSRAM JCN
        ;savepath .File1/name DEO2 ( open SAV file )

        ;isSingleRAMBank LDA ,&saveSingleBank JCN
          ( write current bank to its bank file )
          ;MBCRegs/RAMBank LDA ( get current bank number )
          #41 ADD ( calculate ASCII value for bank number (A-P), hex would be nice but is harder to generate )
          ;bankPathDigit STA ( replace bank character in bankPath )
          ;bankPath .File0/name DEO2 ( set name for bank file )
          ;sram .File0/write DEO2 ( write out to bank file )
          #0000 .File0/name DEO2 ( close bank file )

          ( repack multiple SRAM bank files )
          #2000 .File0/length DEO2 ( set length for reads from bank files )
          #00 ( counter )
          &packLoop
            DUP #41 ADD ( calculate ASCII value for bank number (A-P), hex would be nice but is harder to generate )
            ;bankPathDigit STA ( replace bank character in bankPath )
            ;bankPath .File0/name DEO2 ( set name for bank file )
            ;sram .File0/read DEO2k POP .File1/write DEO2 ( read from bank file to memory, write out to SAV file )
            #00 .File0/delete DEO ( delete bank file )
          INC GTHk ,&packLoop JCN
          POP
          ,&doneSRAMHandling JMP
        &saveSingleBank
          ;sram .File1/write DEO2 ( write out to bank file )
          #0000 .File1/name DEO2 ( close bank file )          
        &doneSRAMHandling
      &noSRAM
      POP
      HALT
      ( doesn't halt in uxn32 immediately? )
    &no-esc
    DUP #2f GTH OVR #3a LTH #0101 NEQ2 ,&no-num JCN ;set-frameskip JSR2 &no-num
  POP

  ( update in-memory GB format joypad byte )
  ( Note: GB can only access one nibble at a time. Based on the value )
  (  written to io/rP1 bits 4/5 we copy the appropriate nibble into   )
  (  the low nibble of io/rP1. We also don't mimic bounce. )

  ( 7654 3210   Varvara  Game Boy )
  ( |||| |||+ - A        A        )
  ( |||| ||+- - B        B        )
  ( |||| |+-- - Select   Select   )
  ( |||| +--- - Start    Start    )
  ( |||+ ---- - Up       Right    )
  ( ||+- ---- - Down     Left     )
  ( |+-- ---- - Left     Up       )
  ( +--- ---- - Right    Down     )

  .Controller/button DEI

  ( change high nibble from UDLR to RLUD )
  STHk ( copy to rst )
  #30 AND #20 SFT ( isolate UD, shift )
  STHkr #40 AND #01 SFT ( isolate L, shift )
  STHkr #80 AND #03 SFT ( isolate R, shift )
  ORA ORA ( collapse into single byte )
  STHr #0f AND ( recover action buttons only )
  ORA ( combine action + dpad buttons )

  #ff EOR ( flip bits, as GB uses 0=pressed )
  ;joypad STA

BRK

@set-frameskip
  #2f SUB ( subtract 1 less than required for ASCII since frameskip value has +1 offset )
  ;frameSkip STA
JMP2r

@on-frame ( -- )
  ( begin CPU instruction execution )
  &loop
    ( check if halt should be ended )
    ;io/rIF LDA ;rIE LDA AND
      STHk #00 EQU ,&skipInterrupts JCN
      #00 ;halt STA ( end halt blindly )
    ;IME LDA #00 EQU ,&skipInterrupts JCN ( check if interrupts should be serviced )
      ( service any interrupts which have occurred, in priority order )
      STHr ( recover pending interrupt bits )
      LITr 00 ( interrupt counter on rst )
      &irqLoop
        #00 ( byte to shift flags into )
        #01 SFT2 ,&serviceIRQ JCN ( shift next interrupt bit into lower byte, check if active )
        INCr ( increment interrupt counter )
        DUP ,&irqLoop JCN ( loop as long as there are unhandled bits )
        POP ( cleanup wst )
        ,&irqServiceDone JMP
        &serviceIRQ
          ( clear IF bit )
          ;io/rIF LDAk
            #01 ( base mask bit )
            STHkr #40 SFT SFT ( get interrupt counter, shift mask bit )
            EOR ( clear appropriate IF flag )
            ROT ROT STA ( store new rIF value )
          #00 ;IME STA ( clear IME )
          ;cycles LDA2k #0008 ADD2 SWP2 STA2 ( cycles += 8 )
          ;PC LDA2 SWP ;pushShort JSR2 ( push PC )
          #00 STHkr #30 SFT #40 ADD ( calculate handler address )
          ;PC STA2 ( set PC to interrupt handler location )
          POP ( cleanup wst )
    &irqServiceDone
    &skipInterrupts
    POPr ( discard pending interrupts OR interrupt counter )

    PRINTSTATE

    ;halt LDA ,&do-halt JCN ,&do-instr JMP &do-halt TICK2 ;&handleCycles JMP2 ( halt )

    &do-instr

    ( debug break at sm83 PC )
    ( ;PC LDA2 #02de NEQ2 ,&noBreak JCN DBG &noBreak )

    READ8PC ( get opcode at PC, PC++ )

      #cb NEQk NIP ,&no-Prefix JCN
        ( Prefix instructions )
        POP READ8PC ( get opcode at PC, PC++ )
        DUP #c0 AND ,&bitResSet JCN
          ( shifts/rotates )
          #00 OVR #02 SFT #0e AND ;shiftRotateJumpTable ADD2 LDA2 ( obtain jump table addr )
          JSR2 ( call handler )
          ;&doneInstr JMP2

        &bitResSet
          #00 OVR #05 SFT #06 AND ;bitResSetJumpTable ADD2 LDA2 ( obtain jump table addr )
          JSR2 ( call handler )
          ;&doneInstr JMP2
      &no-Prefix

      #00 OVR #10 SFT2 ;instrJumpTable ADD2 LDA2 ( obtain jump table addr )
      JSR2 ( call handler )

    &doneInstr
    POP

    &handleCycles

    ;cycles LDA2 ;prevCycles LDA2 
      SUB2k [ STH2k ] ( copy for timer handling ) ;io/rDIVlow LDA2 SWP ADD2 SWP ;io/rDIVlow STA2 ( advance 16bit rDIV, Note: using $ff03 to store low byte of rDIV )

    ( Update timer and timer interrupt )
    ( Note: We duplicate the 16bit DIV counter as timerShort, which has the shifted cycle delta added to it. Ideally we'd 
      just reference changes to the DIV counter, but I couldn't figure out how to implement the falling edge detector without 
      looping over each cycle change in DIV. )
    ;io/rTAC LDA
      DUP #04 AND #00 EQU ,&timerDisabled JCN ( check if timer is enabled )
        #00 SWP ;TACShiftLookup ADD2 LDA ( get shift value for TAC setting )
        STH2kr ( recover cycle delta, leave on rst to balance stacks on exit )
        ROT SFT2 ( shift cycle delta by shift value based on TAC setting )
        ;timerShort LDA2 ( get current timerShort value )
        ADD2k ( add shifted delta, keep arguments to detect overflow )
        LTH2k ,&noOverflow JCN ( check if prior value is smaller than the new value, in which case we didn't overflow )
          ;io/rIF LDAk #04 ORA ROT ROT STA ( set Timer IF flag )
          NIP ( discard ADD2k result high byte )
          ;io/rTMA LDA SWP ( replace high byte with TMA value, but retain low byte )
        &noOverflow
        ;timerShort STA2k ( store new timerShort value )
        POP2 ( discard timerShort addr ) POP ( discard low byte )
        ;io/rTIMA STA ( store new TIMA value )
        POP2 POP ( discard addition arguments, except for an extra byte to balance trailing pop )
      &timerDisabled
    POP ( cleanup wst )

    ;io/rLCDC LDA #80 AND #00 NEQ ,&lcd-on JCN
      #00 ;io/rLY STAk POP2 DUP ;ppuDot STA2 ( if the LCD is disabled, LY = 0, ppuDot = 0, skip rendering )
      POP2r ( discard cycle delta )
      ,&doneModeCycle JMP
    &lcd-on
      LIT2r =ppuDot LDA2kr ROT2r ADD2r SWP2r STA2kr POP2r ( ppuDot += cycleDelta )
        
        ;io/rSTAT LDAk DUP #03 AND #20 SFT #00 SWP ( isolate mode bits, build table offset )
        ;modeJumpTable ADD2 LDA2k ( read ppuDot threshold )
        STH2 LTH2r LITr _&skipHandler JCNr
          INC2 INC2 LDA2 JMP2 ( call handler having passed ppuDot threshold for this mode )
        &skipHandler
        POP2 ( discard handler pointer )
        POP POP2 ( discard rSTAT and addr )
 
    &doneModeCycle
    POP2 ;prevCycles STA2 ( set prevCycles == cycles, as we've caught up )
    
    ;&loop JMP2

  HALT
BRK

( For each mode 0-3, if the given ppuDot has been exceeded, call the associated handler )
( The purpose of this approach is to reduce the unique checks performed per instruction loop )
@modeJumpTable ( 0: hblank, 1: vblank, 2: oam scan, 3: rendering )
[ 01c7 =scanlineDone 01c7 =vblankScanlineDone 004f =oamScan 0105 =renderScanline ]

@oamScan
  ( Note: OAM scan is actually a part of the renderScanline call right now, which means we check for sprites late in the line... )
  #fc AND #03 ORA ( set STAT mode to drawing [3], explicity set to 3 to handle case when LCD recently turned on )
  ROT ROT STA
;on-frame/doneModeCycle JMP2

@renderScanline
  DUP #08 AND #00 EQU ,&noStatHblank JCN 
    ;io/rIF LDAk #02 ORA ROT ROT STA ( request STAT hblank interrupt if enabled )
  &noStatHblank
  #fc AND ( set STAT mode to HBlank [0], length not adjusted for sprites/etc )
  ROT ROT STA

  LIT2 &skipThisFrame [ $1 ] _on-frame/doneModeCycle JCN ( frame skip condition is injected directly here for a quick exit )

  ( perform rendering of this scanline now, since we don't want changes to LCDC/etc during hblank to affect this line )

  ( draw scanline )
  #00 ;io/rLY LDA .Screen/y DEO2 ( set varvara Y coordinate )
  #0000 .Screen/x DEO2 ( set varvara X coordinate )
  #01 .Screen/auto DEO ( set varvara auto X )

  ( TODO: See if writing 8 scanlines progressively to a buffer of 2bpp tiles in UXN RAM and then using
    two 10-tile Screen/sprite calls is faster than this per-pixel drawing. Though uxnemu seems faster
    than uxn32 in this regard, so it might depend on the host VM. )

  LIT2r =oamScanTable ( setup pointer to store sprites for this scanline )
  #02 ;io/rLCDC LDA AND #00 EQU ;&skipOAMScan JCN2 ( check if sprites are enabled )

    ( Perform OAM scan, identifying the first 10 sprites which are visible on this scanline. Copy the required
      data to render each sprite on this line to the oamScanTable for use during rendering. )
    
    ( calculate sprite XOR value and height for visibility calculation, write ahead )
    #0f [ #04 ;io/rLCDC LDA AND ,&tallSprites JCN POP #07 &tallSprites ] 
      DUP ,&spriteYXOR STR
      DUP #03 SFT #ff EOR ,&tileIDMask STR ( AND mask for bit0 of tileID for 8x16 sprites )
      INC ,&spriteHeight STR
    ;io/rLY LDA #10 ADD ,&lyPlus16 STR ( write LY+16 ahead )

    #2800 ( setup 0-40 counter, for the 40 sprite entries )
    &oamScanLoop
      ( wst: ? ? ? ? #a0 px bgPxColor #28 lowAddr )
      ( rst: )

      #fe OVR #20 SFT ( point to OAM entry )
      LDAk ( read Y ) LIT [ &lyPlus16 $1 ] SWP SUB ( spriteY = LY + 16 - Y ) 
        DUP LIT [ &spriteHeight $1 ] LTH ,&yVisible JCN POP POP2 ,&nextSprite JMP ( not visible based on height )
        &yVisible ,&spriteY STR ( write ahead )

      INC ( advance to X )
      LDAk STH ( read X, move to rst )
      INC ( advance to tileID )
      LDA2 STH2 ( read tileID, attr and move to rst )
      DUPr LITr _&attr STRr ( push attr ahead for caching )

      ( yOffset = ( spriteY ^ 7|0 ) * 2 )
      LIT2 [  &spriteY $1 &spriteYXOR $1 ] STHr #40 AND ,&vFlip JCN POP #00 &vFlip EOR #10 SFT ,&ySprOffset STR

      ( wst: #28 lowAddr )
      ( rst: oamScanTable* X tileID )

      LIT2 00 [ &ySprOffset $1 ]

      #00 STHr ( setup tileID as short )
      LIT [ &tileIDMask $1 ] AND ( clear bit0 for 8x16 mode )
      #40 SFT2 ( * 16 )
      #8000 ADD2 ( add tile data base addr )
      ADD2 ( yOffset + addr to get addr of sprite tile data )

      STHr ( move X back to wst )
      ( wst: #28 lowAddr tileAddr X )
      ( rst: oamScanTable* )

      ( Store in oamScanTable: X high low attr )
      STH2kr STA INC2r ( write X to oamScanLoop, inc ptr )
      LDAk ( get tile low byte )
      STH2kr STA INC2r ( write tileLowByte to oamScanTable, inc ptr )
      INC2 LDA ( get tile high byte )
      STH2kr STA INC2r ( write tileHighByte to oamScanTable, inc ptr )
      LIT [ &attr $1 ] ( attr byte )
      STH2kr STA INC2r ( write attr to oamScanTable, inc ptr )

      ( wst: #28 lowAddr )
      ( rst: oamScanTable* )

      ( the oamScanTable is aligned such that when we reach 10 entries the low byte will be zero )
      DUPr LITr 00 EQUr LITr _&reached10Sprites JCNr

    &nextSprite
    INC GTHk ,&oamScanLoop JCN
  &reached10Sprites
  POP2

  &skipOAMScan
  LITr ff ROTr ROTr STAr ( write table teriminator, either to skip sprites entirely OR for the end of the table content )

  ( Pre-calculate and STR ahead as many values that are static for the scanline as possible, for speed )
  #01 ;io/rLCDC LDA AND ,&isBGEnabled STR
  #20 ;io/rLCDC LDA AND #00 EQU ( check if window is disabled in rLCDC )
    ;io/rLY LDA ;io/rWY LDA LTH ORA ( or LY < WY )
    ;io/rWX LDA #a6 GTH ORA ( or WX > 166 )
      DUP ,&isWinInactive STR ( then the window is inactive this scanline )
      ,&skipWinVariables JCN
        ;io/rWX LDA ,&wx STR ( Can't pre-calculate WX-7 because WX values of 0-6 result in negative value, breaking the LTH check )
        ;WLY LDAk 
          DUP ,&WLY STR ( yOffset = WLY )
        INC ROT ROT STA ( increment WLY for the next scanline only when the window is active )
      &skipWinVariables
  ;io/rLY LDA ;io/rSCY LDA ADD ,&lyPlusSCY STR ( yOffset = LY + SCY )
  #10 ;io/rLCDC LDA AND #10 EQU ,&isTileBlock0Cache STR ( are bg/win using tile block 0? )

  #a000 ( setup 0-160 pixel counter )
  &pxLoop
    ( Is BG enabled? If not, set bgPxColor to 0 and jump to sprite handling )
    LIT2 &isBGEnabled [ $1 _&bgEnabled ] JCN #00 ( bgPxColor = 0 ) ;&sprites JMP2
    &bgEnabled ( applies to window as well on DMG )

    ( Is window active this scanline? )
    LIT2 [ &isWinInactive $1 _&drawBackground ] JCN
      DUP #07 ADD LIT [ &wx $1 ] LTHk ,&notYetWindow JCN ( Is px + 7 >= WX? )
        SUB ( xOffset = px - ( WX - 7 ) )
        DUP ,&xOffsetCache STR ( copy for later )
        #ff ;bgwinMaskedXOffset STA ( Invalidated xOffset cache to trigger tilemap/data fetch )
      LIT2 00 [ &WLY $1 ] ( yOffset = WLY )
        #40 ,&lcdcTilemapMask STR
      ,&readTilemap JMP
    &notYetWindow
    POP2 ( discard px, ( WX - 7 ) )

    &drawBackground
    DUP ;io/rSCX LDA ADD ( xOffset = px + SCX )
      DUP ,&xOffsetCache STR ( copy for later )
    LIT2 00 [ &lyPlusSCY $1 ] ( yOffset = LY + SCY )
      #08 ,&lcdcTilemapMask STR

    &readTilemap
    ( wst: a0 pxCount xOffset yOffsetShort )

    ( Check cached xOffset to determine if it's empty )
    ( Note: This is SLIGHTLY faster than not caching the data, confirmed through testing. Though I'd like
      to find a way to further optimize it. )
    LIT2r =bgwinMaskedXOffset LDAr ( read cached maskedXOffset )
    DUPr LITr ff EQUr LITr _&loadNewBgWinTile JCNr ( check if we need new tile data )
      POP2 POP ( discard yOffset and xOffset from wst )
      ;bgwinTileDataHigh LDA ( read high byte onto wst )
      STHkr ( copy bgwinMaskedXOffset to wst )
      DUP #01 SUB ;bgwinMaskedXOffset STA ( decrement for next pass )
      LIT2r =bgwinTileDataLow LDAr ( read low byte onto rst )
      SWPr ( swap bgwinMaskedXOffset and low byte on rst )
      ;&resumeBgWinTileRender JMP2 ( jump to rendering now that we're ready )
    &loadNewBgWinTile
    POPr ( discard old bgwinMaskedXOffset )

    LIT2 [ &isTileBlock0Cache $1 &xOffsetCache $1 ]
      ,&xOffset STR ( push xOffset along, TODO: remove if distance shortens enough )
      ,&isTileBlock0 STR ( push isTileBlock0 along, TODO: remove if distance shortens enough )

      DUP ,&yOffset STR ( copy for later )
      #53 SFT2 ( yOffset / * 32 )
    ROT ( move xOffset byte to top of wst )
      #03 SFT ( xOffset / 8 )
      #00 SWP ( convert to short )
    #0006 ( setup for $9800 )
      LIT [ &lcdcTilemapMask $1 ] ;io/rLCDC LDA AND ( check LCDC tilemap bit )
      #00 EQU ,&firstTilemap JCN INC &firstTilemap ( if tilemap bit set, increment base value )
    #a0 SFT2 #8000 ADD2 ( calculate tilemap base address, $9800 or $9c00, from $8000 + 6|7 << 10 )

    ADD2 ADD2 ( baseAddr + yOffset + xOffset = tilemap VRAM addr )
    LDA ,&tileID STR ( read tileID from tilemap, write ahead for seeking tile data )

    ( #82 ;io/rLCDC LDA NEQ ,&noBRK JCN DBG &noBRK ( break on LCDC==#82 ) )

    #00 LIT [ &yOffset $1 ] #07 AND #10 SFT ( yOffset % 8 * 2 )

    LIT2 00 [ &tileID $1 ] ( setup tileID as short )
    LIT2 [ &isTileBlock0 $1 _&tileBlock0 ] JCN
      #ff OVR #07 SFT ,&negativeTileID JCN POP #00 &negativeTileID OVR ( sign extension )
      NIP2 ( discard entire original tileID -> TODO: find a way to consume it instead )
      #0100 ADD2 ( tileBlock1 ) 
    &tileBlock0
    #40 SFT2 ( * 16 )
    #8000 ADD2 ( add tile data base addr )

    ADD2 ( addr + yOffset component to get addr of bg/win tile data )

    LDAk STHk ;bgwinTileDataLow STA ( get tile low byte, move to rst and cache )
    INC2 LDA DUP ;bgwinTileDataHigh STA ( get tile high byte, copy to cache )

    LIT [ &xOffset $1 ] #07 EORk AND NIP ( xOffset = ( xOffset ^ 7 ) & 7 )
    STHk ( copy xOffset to rst )

    DUP #01 SUB ;bgwinMaskedXOffset STA ( cache masked xOffset to fast-track bg/win rendering for the next pixel )

    &resumeBgWinTileRender

    ( px color = ( high >> xOffset ) % 2 * 2 + ( low >> xOffset ) % 2 )
    SFT #01 AND #10 SFT ( high bit )
    STH2r ( recover low byte and xOffset from rst )
    SFT #01 AND ( low bit )
    ADD ( final bg/win pixel color! )

    #47 ;pxPaletteAddr STA ( default to bg/win palette )

    ( Sprites! )
    &sprites

    ( wst: ? ? ? ? #a0 px bgPxColor )
    ( rst: )

    OVR #08 ADD ,&pxPlus8 STR ( write px+8 ahead, which is a waste if there are no visible sprites... )

    LIT2r =oamScanTable ( point at oamScanTable, which tracks visible sprites this scanline )
    &spriteLoop
      ( wst: ? ? ? ? #a0 px bgPxColor )
      ( rst: oamScanTable* )

      LDAkr ( read X/terminator )
      DUPr LITr ff EQUr LIT2r =&endOfTable JCN2r ( check for table terminator )
      LITr [ &pxPlus8 $1 ] SWPr SUBr ( spriteX = px + 8 - X )
        DUPr LITr 08 LTHr LITr _&xVisible JCNr
          POPr INC2r INC2r INC2r INC2r LITr _&spriteLoop JMPr ( not visible based on width, advance to next entry )
        &xVisible

      LITr _&X STRr ( push X ahead )

      ( wst: )
      ( rst: oamScanTable* )

      INC2r LDAkr STHr ( read tileHighByte, move to wst )
      INC2r LDAkr STHr ( read tileLowByte, move to wst )
      INC2r LDAkr ( read attr )

      ( wst: tileHighByte tileLowByte  )
      ( rst: oamScanTable* attr )

      ( xOffset = ( spriteX ^ 0|7 ) )
      LITr 00 OVRr LITr 20 ANDr LITr _&hFlip JCNr POPr LITr 07 &hFlip ( get 0 or 7 to EOR X with based on attr byte )
      LITr [ &X $1 ] EORr ( X is STR'd here earlier )
      STHkr ( copy xOffset to wst )
      SWP ( get xOffset into place for high byte )
      STHr ( move xOffset into place for low byte )

      ( wst: tileHighByte xOffset tileLowByte xOffset )
      ( rst: oamScanTable* attr )

      ( px color = ( high >> xOffset ) % 2 * 2 + ( low >> xOffset ) % 2 )
      SFT #01 AND #10 SFT ( high bit )
      ROT ROT
      SFT #01 AND ( low bit )
      ADD ( final sprite pixel color! )

      ( wst: #a0 px bgPxColor sprPxColor )
      ( rst: oamScanTable* attr )

      ( decide if we should show the bg/win or sprite pixel color )
      DUP #00 NEQ ,&sprPxOpaque JCN ( sprPx transparent, don't draw ) POP POPr INC2r ,&spriteLoop JMP
      &sprPxOpaque
        STHkr ( copy attr ) #80 AND ( check sprite's BG priority bit ) #00 NEQ ,&checkBgPxColor JCN
          ( no BG priority, draw sprite )
          NIP ( discard bgPxColor )
        &handleSprPalette
          #48 ( lowAddr of OBP0 )
          STHr ( recover attr byte )
          #10 AND #04 SFT ADD ( Add shifted palette bit onto lowAddr )
          ;pxPaletteAddr STA ( store for drawing )
          ,&palettes JMP ( jump to draw this sprite pixel )
        &checkBgPxColor
        ( check if BG color 1-3 )
        STH ( move sprPxColor to rst ) DUP ( get copy of bgPxColor )
        #00 EQU ,&showSprPx JCN ( BG has priority and is color 1-3, skip this sprite ) POP2r INC2r ;&spriteLoop JMP2
        &showSprPx
          POP ( discard bgPxColor )
          STHr ( recover sprPxColor from rst )
          ,&handleSprPalette JMP

    &endOfTable
    POPr ( discard X/terminator )

    ( apply palette to final pixel color )
    &palettes
    POP2r ( discard oamScanTable* )

    #10 SFT ( color * 2 = shift count )
    #ff ;pxPaletteAddr LDA ( get palette addr )
    LDA ( get palette value )
    SWP ( swap color/shift )
    SFT ( shift palette to get color in bit 0-1 )
    #03 AND ( mask off extra bits )

    #80 ADD ( enable 2bpp mode )
    .Screen/pixel DEO ( draw pixel, at last! )

  INC GTHk ;&pxLoop JCN2
  POP2 ( discard pixel counter )

;on-frame/doneModeCycle JMP2

@vblankScanlineDone
  POP POP2 ( discard STAT value and addr )
  ,scanlineDone/doneModeAdvance JMP

@scanlineDone
  ( for non-vblank scanlines, advance from hblank [0] to OAM search [2] )
  INC INC ROT ROT STAk POP2 ( set STAT mode to OAM search [2], mode 2 always follows 0, so INC INC works )
  #20 AND #00 EQU ,&noStatOAM JCN 
    ;io/rIF LDAk #02 ORA ROT ROT STA ( request STAT OAM interrupt if enabled )
  &noStatOAM

  &doneModeAdvance
  ;io/rLY LDAk ( get current LY ) INC ( increment LY )

  ;io/rSTAT LDA #40 AND #00 EQU ,&noStatLYC JCN 
    DUP ;io/rLYC LDA NEQ ,&lyNEQlyc JCN
      ;io/rIF LDAk #02 ORA ROT ROT STA ( request STAT LYC interrupt if enabled )
  &noStatLYC
  &lyNEQlyc

  DUP #9a LTH ,&not-new-frame ( check if we're done VBlank )
    JCN POP #00 ( reset to LY = 0 )
    DUP ;WLY STA ( reset WLY for next frame )
    ;io/rSTAT LDAk #fc AND #02 ORA ROT ROT STA ( set STAT mode to OAM scan [2] )
  &not-new-frame
  ROT ROT STA ( LY = (LY + 1) % 154 )
  ;ppuDot LDA2k #01c8 SUB2 SWP2 STA2 ( subtract a line of ppuDots off, since we allow overshooting )
  #ff ;bgwinMaskedXOffset STA ( reset bgwinMaskedXOffset for the next scanline )

  ;io/rLY LDA #90 NEQ ,&notVblankStart JCN
    #01 ( setup to enable VBlank IF flag up ahead )
    ;io/rSTAT LDAk #fc AND INC ROT ROT STAk POP2 ( set STAT mode to VBlank [1] )
    #10 AND #00 EQU ,&noStatVBLANK JCN
      INC INC ( increment prepared IF flag addition to include STAT VBlank interrupt )
    &noStatVBLANK
    STH ;io/rIF LDAk STHr ORA ROT ROT STA ( set VBlank and possible STAT VBlank IF flags )

    ( update frameSkip state, TODO: Clean this up, it feels excessively complex )
    ;frameSkipCounter LDAk #01 SUB ( decrement counter )
    #00 NEQk NIP DUP ;renderScanline/skipThisFrame STA ( store skip boolean for next frame )
    ,&skippingNext JCN
      POP ;frameSkip LDA ( reset counter )
    &skippingNext
    ROT ROT STA ( store new counter )
    VBLANK
  &notVblankStart

;on-frame/doneModeCycle JMP2

(
@emulatorState )
( B C D E H L F A SPhigh SPlow - UXN is big endian, so no benefit to inverting pairs )
( Note: We have to swap high/low read from ROM (u6) though... so maybe inversion has uses? )
( Note: This order is important as it matches the r8 table order, except for F which is the [hl] location. SP doesn't have to be a part of the table. )
( Note: inc/dec r16 would benefit from SP in the FA slot, but it's easy enough to special case that table seek )
( Note: push/pop r16 would benefit from AF ordering instead of FA, but then the [hl] case would have to be handled differently... )
@reg8 [ &B 00 &C 13 &D 00 &E d8 &H 01 &L 4d &F b0 &A 01 &SPhigh ff &SPlow fe ]
@PC [ &high 01 &low 00 ]

( MBC registers - shared! )
@MBCRegs &RAMEnable $1 &RAMBank $1 &ROMBank $1 &ROMBankHigh $1 

( varaboy variables )
@cycles $2
@prevCycles $2
@halt $1
@IME $1
@ppuDot &high $1 &low $1
@joypad $1
@pxPaletteAddr $1
@WLY $1 ( track LY of window independent of LY )
@frameSkip $1
@frameSkipCounter $1
@timerShort $1 @timerShortLow $1
@SRAMBanks $1 ( number of SRAM banks in use )
@isSingleRAMBank $1 ( flag indicating if a single RAM bank is in use )
@loadedRAMBank $1 ( RAM bank currently loaded from disk into memory at $A000 )

( PPU cache to reuse data )
@bgwinMaskedXOffset $1
@bgwinTileDataLow $1
@bgwinTileDataHigh $1

@filepath $40
@default-gb "other\fruitpursuit.gb $1
@savepath $40
@saveExtension "sav $1
@bankPath "_bank @bankPathDigit "A.sav $1

~src/opcodes.tal

(
@|writeHandler )

@write8 ( value addr -- )

  ( General write handlers regardless of MBC )

  ( Joypad select )
  DUP2 ;io/rP1 NEQ2 ,&notJoypad JCN
    POP2 ( discard addr )
    #30 AND ( clear old low nibble of rP1 )
    DUP #20 NEQ ,&notAction JCN
      ;joypad LDA #f0 AND ( get high nibble of joypad state )
      #04 SFT ( shift to low nibble )
      ,&doneJoypad JMP
    &notAction
    DUP #10 NEQ ,&notDirection JCN
      ;joypad LDA #0f AND ( get low nibble of joypad state )
      ,&doneJoypad JMP
    &notDirection
      #0f ( everything unpressed )
    &doneJoypad
    ORA ;io/rP1 STA ( set new states, store rP1 )
    JMP2r
  &notJoypad

  ( OAM DMA )
  DUP2 ;io/rDMA NEQ2 ,&notOAMDMA JCN
    POP2 ( discard addr )
    STH ( move high byte to rst )
    #a000 ( copy 160 bytes )
    &oamdmaLoop
      STHkr OVR ( address of byte to copy )
      LDA ( read byte )
      OVR #fe SWP ( OAM address to copy to )
      STA ( write byte )
    INC GTHk ,&oamdmaLoop JCN
    POP2 ( discard loop counters )
    POPr ( discard high byte on rst )
    JMP2r
  &notOAMDMA

  ( DIV reset )
  DUP2 ;io/rDIV NEQ2 ,&notDIV JCN
    POP2 POP ( discard all inputs )
    #0000 ;io/rDIVlow STA2k ( reset entire counter )
    POP2 ;timerShort STA2 ( also reset timerShort duplicate counter )
    JMP2r
  &notDIV

  ( TIMA duplicate write to internal timer tracker )
  DUP2 ;io/rTIMA NEQ2 ,&notTIMA JCN
    STAk ( carry out actual write )
    POP2 ( discard target addr )
    ;timerShort STA ( duplicate write to shadow byte, leaving low byte untouched )
    JMP2r
  &notTIMA

  ( IF is a 5 bit register, so always set the top 3 bits )
  DUP2 ;io/rIF NEQ2 ,&notIF JCN
    ROT #e0 ORA ( set top 3 bits )
    ROT ROT STA ( write )
    JMP2r
  &notIF

  ( fall through into MBC handler )
@MBCHandler $100 ( reserve space for MBC handler to be copied to )

(
@uxnUtility )
@print-state ( -- )
  ;str-BC ;pstr JSR2 ;reg8/B LDA ;print-hex JSR2 ;reg8/C LDA ;print-hex JSR2
  ;str-DE ;pstr JSR2 ;reg8/D LDA ;print-hex JSR2 ;reg8/E LDA ;print-hex JSR2
  ;str-HL ;pstr JSR2 ;reg8/H LDA ;print-hex JSR2 ;reg8/L LDA ;print-hex JSR2
  ;str-AF ;pstr JSR2 ;reg8/A LDA ;print-hex JSR2 ;reg8/F LDA ;print-hex JSR2
  ;str-SP ;pstr JSR2 ;reg8/SPhigh LDA ;print-hex JSR2 ;reg8/SPlow LDA ;print-hex JSR2
  ;str-PC ;pstr JSR2 ;PC/high LDA ;print-hex JSR2 ;PC/low LDA ;print-hex JSR2
  ( ;str-LY ;pstr JSR2 ;io/rLY LDA ;print-hex JSR2
  ;str-dot ;pstr JSR2 ;ppuDot/high LDA ;print-hex JSR2 ;ppuDot/low LDA ;print-hex JSR2
  ;str-stat ;pstr JSR2 ;io/rSTAT LDA ;print-hex JSR2
  ;str-timerShort ;pstr JSR2 ;timerShort LDA ;print-hex JSR2 ;timerShortLow LDA ;print-hex JSR2 ;io/rTIMA LDA ;print-hex JSR2
  ;str-TIMA ;pstr JSR2 ;io/rTIMA LDA ;print-hex JSR2 )
  #0a .Console/write DEO
JMP2r

@str-BC "BC= $1
@str-DE 20 "DE= $1
@str-HL 20 "HL= $1
@str-AF 20 "AF= $1
@str-SP 20 "SP= $1
@str-PC 20 "PC= $1
@str-LY 20 "LY= $1
@str-dot 20 "ppuDot= $1
@str-stat 20 "stat= $1
@str-timerShort 20 "tShort= $1
@str-TIMA 20 20 "@$ff05 20 "= 20 "$ $1

@print-hex ( byte -- )
  DUP
  ( lowercase hex use #27, uppercase: #07 )
  #04 SFT #30 ADD [ #3a LTHk NIP ,&highDigit JCN #07 ADD &highDigit ] .Console/write DEO
  #0f AND #30 ADD [ #3a LTHk NIP ,&lowDigit JCN #07 ADD &lowDigit ] .Console/write DEO
JMP2r


(
@|stdlib )

@scap ( str* -- end* ) LDAk #00 NEQ JMP JMP2r &w INC2 LDAk ,&w JCN JMP2r
@sput ( chr str* -- ) ,scap JSR STA JMP2r
@slen ( str* -- len* ) DUP2 ,scap JSR SWP2 SUB2 JMP2r
@scmp ( a* b* -- f ) STH2 &l LDAk LDAkr STHr ANDk #00 EQU ,&e JCN NEQk ,&e JCN POP2 INC2 INC2r ,&l JMP &e NIP2 POP2r EQU JMP2r
@sclr ( str* -- ) LDAk ,&w JCN POP2 JMP2r &w STH2k #00 STH2r STA INC2 LDAk ,&w JCN POP2 JMP2r
@scpy ( src* dst* -- ) OVR2 LDA ,&e JCN POP2 POP2 JMP2r &e STH2 &w LDAk STH2kr STA INC2r INC2 LDAk ,&w JCN POP2 #00 STH2r STA JMP2r
@skey ( key buf -- proc ) OVR #21 LTH ,&eval JCN #00 SWP ;sput JSR2 #00 JMP2r &eval POP2 #01 JMP2r
@pstr ( str* -- ) &w LDAk #18 DEO INC2 LDAk ,&w JCN POP2 JMP2r

@load-theme ( -- )
    ;theme/path .File0/name DEO2
    #0006 .File0/length DEO2
    ;theme/data .File0/read DEO2
    .File0/success DEI2 #0006 NEQ2 ,&failed JCN
        ( set system colors from loaded theme )
        ;theme/r LDA2 .System/r DEO2
        ;theme/g LDA2 .System/g DEO2
        ;theme/b LDA2 .System/b DEO2
    &failed
    #0000 .File0/name DEO2 ( close file to allow deletion while running )
JMP2r
@theme
    &path ".theme $1
    &data [ &r $2 &g $2 &b $2 ]

( Note: This table is intentionally aligned such that the 41st entry will have a low byte of 0, 
  to help in detecting when it has been filled with 10 entries. There's likely a better way to do
  this, and a way to ensure we don't clobber it by accident. There might even be a sneaky place to
  store it to minimize waste. )
|fcd8 @oamScanTable $29 ( [ xCoord tileHighByte tileLowByte attr ] * 10, plus terminator )

( Note: This must end before fdff to avoid overflowing into Game Boy address space )
