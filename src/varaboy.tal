( varaboy.tal )

(
@|devices )
|00 @System     [ &vector $2 &pad $6 &r $2 &g $2 &b $2 &debug $1 &state $1 ]
|10 @Console    [ &vector $2 &read $1 &pad $5 &write $1 &error $1 ]
|20 @Screen     [ &vector $2 &width $2 &height $2 &auto $1 &pad $1 &x $2 &y $2 &addr $2 &pixel $1 &sprite $1 ]
|80 @Controller [ &vector $2 &button  $1 &key $1 ]
|90 @Mouse      [ &vector $2 &x $2 &y $2 &state $1 &pad $3 &scrollx $2 &scrolly $2 ]
|a0 @File0      [ &vector $2 &success $2 &stat $2 &delete $1 &append $1 &name $2 &length $2 &read $2 &write $2 ]
|b0 @File1      [ &vector $2 &success $2 &stat $2 &delete $1 &append $1 &name $2 &length $2 &read $2 &write $2 ]

(
@|macros )
%EMIT { .Console/write DEO }
%HALT { #01 .System/state DEO }
%DBG { #01 .System/debug DEO }

( stdin vs hardcoded filepath )
%READFILE { ;on-console .Console/vector DEO2 }
%xREADFILE { ;default-gb ;filepath scpy !start } ( Note: Switch to this READFILE when using uxn32 to debug )

( release macros )
%INIT { ;on-frame .Screen/vector DEO2 ;on-button .Controller/vector DEO2 }
%VBLANK { POP2 POP2 BRK }
%PRINTSTATE { }

( cli debug macros )
( Note: Switch to this set of macros when using uxncli to dump register trace logs )
%xINIT { !on-frame }
%xVBLANK { ,&afterModeChange JMP }
%xPRINTSTATE { ;print-state JSR2 }

(
@|opcodeMacros )
%READ8PC { TICK [ ;PC LDA2k INC2k ROT2 STA2 ] LDA }
( TODO: binji notes that it's necessary to read8/pc++, then read8/pc++ again to avoid undefined behaviour. Do that? )
%READ16 { [ LDA2k INC2k INC2 ROT2 STA2 ] LDA2 SWP TICK2 }
%READ16PC { ;PC READ16 }
%GET-R8-ADDR { [ DUP #06 NEQ ,&simpleR8 JCN [ POP ;reg8/H LDA2 TICK ] ] ,&r8ready JMP &simpleR8 #00 SWP ;reg8 ADD2 &r8ready }
%GET-R8-ADDR_2 { [ DUP #06 NEQ ,&simpleR8_2 JCN [ POP ;reg8/H LDA2 TICK ] ] ,&r8ready_2 JMP &simpleR8_2 #00 SWP ;reg8 ADD2 &r8ready_2 } ( simple duplicate to allow second use in same instr handler )
%GETSET-R8-ADDR { [ DUP #06 NEQ ,&simpleR8 JCN [ POP ;reg8/H LDA2 TICK2 ] ] ,&r8ready JMP &simpleR8 #00 SWP ;reg8 ADD2 &r8ready } ( tick twice since [HL] will be written )
%GET-R16-GROUP1-ADDR { DUP #30 AND #03 SFT [ DUP #06 NEQ ,&notSP JCN INC INC &notSP ] #00 SWP ;reg8 ADD2 }
%TICK { ;cycles LDA2k #0004 ADD2 SWP2 STA2 }
%TICK2 { ;cycles LDA2k #0008 ADD2 SWP2 STA2 }
%POPSHORT { ;reg8/SPhigh READ16 }
%CHECK-FLAG { DUP #e018 ROT AND LDA2 ;reg8/F LDA AND EQU }

~src/mmap.tal

( Note: Only code/data in the e000-fdff range is "safe" during runtime. Code/data here
  must only be used for startup, or copied to the safe region for use during runtime. )
|0100
  ( meta )
  ;meta #f0 DEO2

  ( theme )
  #fc40 .System/r DEO2
  #fc40 .System/g DEO2
  #fc40 .System/b DEO2
  load-theme

	( size )
  #00a0 .Screen/width DEO2
  #0090 .Screen/height DEO2

  ( TODO: find a way to automatically load a default ROM if none is provided on the command line )
  READFILE
BRK

@on-console ( -> )

  ;filepath STH2
  ( read source )
  .Console/read DEI
  DUP #20 LTH OVR #7f GTH ORA ,&end JCN
  STH2kr slen #003f GTH2 ,&end JCN
    STH2r sput BRK
    &end
  POP

  STH2r start

BRK

@start ( src* -- )

  ( build .sav version of filename for SRAM, even if not battery backed )
  ;filepath ;savepath STH2k scpy ( copy filepath to savepath )
  ;saveExtension ( source for .sav extension )
  STH2kr slen #02 SUB STH2kr ADD2 ( get addr of start of extension, assuming 2 letter (gb) extension )
  scpy ( copy sav extension over gb )
  STH2r .File1/name DEO2

  ( Detect MBC type and copy handler to @MBCHandler )
  ;filepath .File0/name DEO2
	#0150 .File0/length DEO2 ( read header to romx for inspection )
	;romx .File0/read DEO2
  #0000 .File0/name DEO2 ( close file to reset addr )

  #00 ;header/ramSize LDA
  ;SRAMBankCounts ADD2 LDA ( get number of SRAM banks )
  DUP #00 EQU ,&noSRAM JCN
    DUP ;SRAMBanks STA ( store for use during banking )
    #2000 .File1/length DEO2 ( SRAM banks are 8KB )
    ;sram .File1/read DEO2 ( attempt read from file )
    .File1/success DEI2 ORA ( check success value ) ,&saveFileExists JCN
      ( zero-fill SRAM file to full size )
      #00 ( counter )
      &SRAMFillLoop
        ;sram .File1/write DEO2
      INC GTHk ,&SRAMFillLoop JCN
      POP
    &saveFileExists
    ( If more than one bank is used, unpack each into a distinct file named _bankX.sav )
    ( Note: This is done so that each SRAM bank can be quickly dumped to disk during SRAM 
      bank swaps. The bank files are repacked on shutdown. )
    ;savepath .File1/name DEO2 ( Reset file seek location )
    DUP #01 EQU DUP ;isSingleRAMBank STA ,&singleBank JCN
      #2000 .File0/length DEO2 ( set length for writes to bank files )
      #00 ( counter )
      &unpackLoop
        DUP #41 ADD ( calculate ASCII value for bank number (A-P), hex would be nice but is harder to generate )
        ;bankPathDigit STA ( replace bank character in bankPath )
        ;bankPath .File0/name DEO2 ( set name for bank file )
        ;sram .File1/read DEO2k POP .File0/write DEO2 ( read from SAV file to memory, write out to bank file )
        #0000 .File0/name DEO2 ( close bank file )
      INC GTHk ,&unpackLoop JCN
      POP
      ;savepath .File1/name DEO2 ( Reset file seek location )
    &singleBank
    ( read SRAM file into SRAM, either single bank or initial multi-bank )
    ;sram .File1/read DEO2
  &noSRAM
  POP
  #0000 .File1/name DEO2 ( close SRAM file )

  #00 ;header/cartridgeType LDA
  DUP #1f GTH ,&unsupportedMBC JCN
  #10 SFT ;MBCHandlerLookup ADD2 LDA2 ( handler start address )
  ;MBCHandler ( destination addr )
  #0080 ( bytes to copy, divided by two )

  ( Just copy the max handler size regardless, as trailing data won't hurt )
  ( Thanks to d_m for this copy routine! )
  ( copies 2-byte pairs from src to dst )
  ( @copy2 ( src* dst* count* -> ) )
  #0000 SWP2 SUB2             ( src* dst* i* )
  STH2 SWP2                   ( dst* src* [i*] )
  &loop
      LDA2k ROT2              ( src* bb* dst* [i*] )
      STA2k NIP2 INC2 INC2 SWP2 INC2 INC2 INC2r   ( dst* src* [i+1*] )
      ORAkr STHr ,&loop JCN   ( dst* src* [i+1*] )
  POP2 POP2 POP2r             ( )

  ( Initialize emulator state )
  #01 ;frameSkip STA ( Note: A value of 1 means no frameskip )
  #01 ;frameSkipCounter STA ( Must be 1 to draw the initial frame )
  
  ( Initialize CPU state )
  ( Note: It feels strange to do this before the ROM is loaded, but doing it here
    means we don't waste valuable safe address space on the code. )
  #91 ;io/rLCDC STA
  #ac00 ;io/rDIV STA2
  #01 ;io/rLY STA ( #00 is likely fine, tuned to better match Emulicious cpu_instrs tracelog )
  #e0 ;io/rIF STA ( IF is a 5 bit register, so the upper 3 bits must be set )

  #ff ;joypad STA ( default to all buttons unpressed )
  #ff #ff4d STA ( make KEY1 read #ff to workaround cpu_instrs test )

  #ff ;bgwinMaskedXOffset STA ( reset bgwinMaskedXOffset to ensure fresh data on the next scanline )

  !varaboy ( jump to program code )

&unsupportedMBC
  ;msg-unsupportedMBC pstr
  HALT

@msg-unsupportedMBC
  "Unsupported 20 "MBC $1

@meta =&end =appicon &body
  ( name ) "Varaboy $1
  ( version ) "Ver. 20 "1 $1
  ( details ) "A 20 "Game 20 "Boy 20 "Emulator $1
  ( author ) "Dave 20 "VanEe 20 7f 20 "2022 $1
  &end $1

~src/assets.tal
~src/mbcs.tal

(
@|varaboy )
( We jump from the uxn entry point $0100 to echo RAM, and operate the emulator from 
  entirely within echo RAM. This allows the Game Boy addresses to remain unmodified, I hope! )
|e000 ( ends at fdff, 1dff[7679] bytes )
( The flag table includes the mask and expected value for the 4 conditional instruction
  options. It's page aligned to speed up check-flag and spaced out so we can use the masked
  portion of the instructions directly without shifting. )
@flag-table [ 00 80 $6 80 80 $6 00 10 $6 10 10 ]

@varaboy
  
  ;filepath .File0/name DEO2
	#8000 .File0/length DEO2 ( read first 32KB directly to memory )
	;rom0 .File0/read DEO2
	( .File0/success DEI2 )
  #0000 .File0/name DEO2 ( close file to reset addr )

  #4000 .File0/length DEO2 ( setup for 8KB per ROM bank reads during runtime )

  ( Setup UXN Screen vector for release mode )
  ( Note: We execute up to the end of LY 143 for every frame vector. This should
    allow uxnemu to operate and also lock us to multiples of 60Hz. )
  INIT ( macro to swap modes for debug )
BRK

@on-button ( -- )

  ( keyboard controls )
  .Controller/key DEI
    [ #1b ] NEQk NIP ,&no-esc JCN
      ( Cleanup SRAM )
      ( Note: Not currently MBC-specific! )
      ;SRAMBanks LDA DUP #00 EQU ,&noSRAM JCN
        ;savepath .File1/name DEO2 ( open SAV file )

        ;isSingleRAMBank LDA ,&saveSingleBank JCN
          ( write current bank to its bank file )
          ;MBCRegs/RAMBank LDA ( get current bank number )
          #41 ADD ( calculate ASCII value for bank number (A-P), hex would be nice but is harder to generate )
          ;bankPathDigit STA ( replace bank character in bankPath )
          ;bankPath .File0/name DEO2 ( set name for bank file )
          ;sram .File0/write DEO2 ( write out to bank file )
          #0000 .File0/name DEO2 ( close bank file )

          ( repack multiple SRAM bank files )
          #2000 .File0/length DEO2 ( set length for reads from bank files )
          #00 ( counter )
          &packLoop
            DUP #41 ADD ( calculate ASCII value for bank number (A-P), hex would be nice but is harder to generate )
            ;bankPathDigit STA ( replace bank character in bankPath )
            ;bankPath .File0/name DEO2 ( set name for bank file )
            ;sram .File0/read DEO2k POP .File1/write DEO2 ( read from bank file to memory, write out to SAV file )
            #00 .File0/delete DEO ( delete bank file )
          INC GTHk ,&packLoop JCN
          POP
          ,&doneSRAMHandling JMP
        &saveSingleBank
          ;sram .File1/write DEO2 ( write out to bank file )
          #0000 .File1/name DEO2 ( close bank file )          
        &doneSRAMHandling
      &noSRAM
      POP
      HALT
      ( doesn't halt in uxn32 immediately? )
    &no-esc
    DUP #2f GTH OVR #3a LTH #0101 NEQ2 ,&no-num JCN ;set-frameskip JSR2 &no-num
  POP

  ( update in-memory GB format joypad byte )
  ( Note: GB can only access one nibble at a time. Based on the value )
  (  written to io/rP1 bits 4/5 we copy the appropriate nibble into   )
  (  the low nibble of io/rP1. We also don't mimic bounce. )

  ( 7654 3210   Varvara  Game Boy )
  ( |||| |||+ - A        A        )
  ( |||| ||+- - B        B        )
  ( |||| |+-- - Select   Select   )
  ( |||| +--- - Start    Start    )
  ( |||+ ---- - Up       Right    )
  ( ||+- ---- - Down     Left     )
  ( |+-- ---- - Left     Up       )
  ( +--- ---- - Right    Down     )

  .Controller/button DEI

  ( change high nibble from UDLR to RLUD )
  STHk ( copy to rst )
  #30 AND #20 SFT ( isolate UD, shift )
  STHkr #40 AND #01 SFT ( isolate L, shift )
  STHkr #80 AND #03 SFT ( isolate R, shift )
  ORA ORA ( collapse into single byte )
  STHr #0f AND ( recover action buttons only )
  ORA ( combine action + dpad buttons )

  #ff EOR ( flip bits, as GB uses 0=pressed )
  ;joypad STA

BRK

@set-frameskip
  #2f SUB ( subtract 1 less than required for ASCII since frameskip value has +1 offset )
  ;frameSkip STA
JMP2r

@on-frame ( -- )
  ( begin CPU instruction execution )
  &loop
    ( check if halt should be ended )
    ;io/rIF LDA ;rIE LDA AND
      STHk #00 EQU ,&skipInterrupts JCN
      #00 ;halt STA ( end halt blindly )
    ;IME LDA #00 EQU ,&skipInterrupts JCN ( check if interrupts should be serviced )
      ( service any interrupts which have occurred, in priority order )
      STHr ( recover pending interrupt bits )
      LITr 00 ( interrupt counter on rst )
      &irqLoop
        #00 ( byte to shift flags into )
        #01 SFT2 ,&serviceIRQ JCN ( shift next interrupt bit into lower byte, check if active )
        INCr ( increment interrupt counter )
        DUP ,&irqLoop JCN ( loop as long as there are unhandled bits )
        POP ( cleanup wst )
        ,&irqServiceDone JMP
        &serviceIRQ
          ( clear IF bit )
          ;io/rIF LDAk
            #01 ( base mask bit )
            STHkr #40 SFT SFT ( get interrupt counter, shift mask bit )
            EOR ( clear appropriate IF flag )
            ROT ROT STA ( store new rIF value )
          #00 ;IME STA ( clear IME )
          ;cycles LDA2k #0008 ADD2 SWP2 STA2 ( cycles += 8 )
          ;PC LDA2 SWP pushShort ( push PC )
          #00 STHkr #30 SFT #40 ADD ( calculate handler address )
          ;PC STA2 ( set PC to interrupt handler location )
          POP ( cleanup wst )
    &irqServiceDone
    &skipInterrupts
    POPr ( discard pending interrupts OR interrupt counter )

    PRINTSTATE

    ;halt LDA ,&do-halt JCN ,&do-instr JMP &do-halt TICK2 !&handleCycles ( halt )

    &do-instr

    ( debug break at sm83 PC )
    ( ;PC LDA2 #02de NEQ2 ,&noBreak JCN DBG &noBreak )

    READ8PC ( get opcode at PC, PC++ )

      #cb NEQk NIP ,&no-Prefix JCN
        ( Prefix instructions )
        POP READ8PC ( get opcode at PC, PC++ )
        DUP #c0 AND ,&bitResSet JCN
          ( shifts/rotates )
          #00 OVR #02 SFT #0e AND ;shiftRotateJumpTable ADD2 LDA2 ( obtain jump table addr )
          JSR2 ( call handler )
          !&doneInstr

        &bitResSet
          #00 OVR #05 SFT #06 AND ;bitResSetJumpTable ADD2 LDA2 ( obtain jump table addr )
          JSR2 ( call handler )
          !&doneInstr
      &no-Prefix

      #00 OVR #10 SFT2 ;instrJumpTable ADD2 LDA2 ( obtain jump table addr )
      JSR2 ( call handler )

    &doneInstr
    POP

    &handleCycles

    ;cycles LDA2 ;prevCycles LDA2 
      SUB2k [ STH2k ] ( copy for timer handling ) ;io/rDIVlow LDA2 SWP ADD2 SWP ;io/rDIVlow STA2 ( advance 16bit rDIV, Note: using $ff03 to store low byte of rDIV )

    ( Update timer and timer interrupt )
    ( Note: We duplicate the 16bit DIV counter as timerShort, which has the shifted cycle delta added to it. Ideally we'd 
      just reference changes to the DIV counter, but I couldn't figure out how to implement the falling edge detector without 
      looping over each cycle change in DIV. )
    ;io/rTAC LDA
      DUP #04 AND #00 EQU ,&timerDisabled JCN ( check if timer is enabled )
        #00 SWP ;TACShiftLookup ADD2 LDA ( get shift value for TAC setting )
        STH2kr ( recover cycle delta, leave on rst to balance stacks on exit )
        ROT SFT2 ( shift cycle delta by shift value based on TAC setting )
        ;timerShort LDA2 ( get current timerShort value )
        ADD2k ( add shifted delta, keep arguments to detect overflow )
        LTH2k ,&noOverflow JCN ( check if prior value is smaller than the new value, in which case we didn't overflow )
          ;io/rIF LDAk #04 ORA ROT ROT STA ( set Timer IF flag )
          NIP ( discard ADD2k result high byte )
          ;io/rTMA LDA SWP ( replace high byte with TMA value, but retain low byte )
        &noOverflow
        ;timerShort STA2k ( store new timerShort value )
        POP2 ( discard timerShort addr ) POP ( discard low byte )
        ;io/rTIMA STA ( store new TIMA value )
        POP2 POP ( discard addition arguments, except for an extra byte to balance trailing pop )
      &timerDisabled
    POP ( cleanup wst )

    ;io/rLCDC LDA #80 AND #00 NEQ ,&lcd-on JCN
      #00 ;io/rLY STAk POP2 DUP ;ppuDot STA2 ( if the LCD is disabled, LY = 0, ppuDot = 0, skip rendering )
      POP2r ( discard cycle delta )
      ,&doneModeCycle JMP
    &lcd-on
      LIT2r =ppuDot LDA2kr ROT2r ADD2r SWP2r STA2kr POP2r ( ppuDot += cycleDelta )
        
        ;io/rSTAT LDAk DUP #03 AND #20 SFT #00 SWP ( isolate mode bits, build table offset )
        ;modeJumpTable ADD2 LDA2k ( read ppuDot threshold )
        STH2 LTH2r LITr _&skipHandler JCNr
          INC2 INC2 LDA2 JMP2 ( call handler having passed ppuDot threshold for this mode )
        &skipHandler
        POP2 ( discard handler pointer )
        POP POP2 ( discard rSTAT and addr )
 
    &doneModeCycle
    POP2 ;prevCycles STA2 ( set prevCycles == cycles, as we've caught up )
    
    !&loop

  HALT
BRK

~src/ppu.tal

(
@emulatorState )
( B C D E H L F A SPhigh SPlow - UXN is big endian, so no benefit to inverting pairs )
( Note: We have to swap high/low read from ROM (u6) though... so maybe inversion has uses? )
( Note: This order is important as it matches the r8 table order, except for F which is the [hl] location. SP doesn't have to be a part of the table. )
( Note: inc/dec r16 would benefit from SP in the FA slot, but it's easy enough to special case that table seek )
( Note: push/pop r16 would benefit from AF ordering instead of FA, but then the [hl] case would have to be handled differently... )
@reg8 [ &B 00 &C 13 &D 00 &E d8 &H 01 &L 4d &F b0 &A 01 &SPhigh ff &SPlow fe ]
@PC [ &high 01 &low 00 ]

( MBC registers - shared! )
@MBCRegs &RAMEnable $1 &RAMBank $1 &ROMBank $1 &ROMBankHigh $1 

( varaboy variables )
@cycles $2
@prevCycles $2
@halt $1
@IME $1
@ppuDot &high $1 &low $1
@joypad $1
@pxPaletteAddr $1
@WLY $1 ( track LY of window independent of LY )
@frameSkip $1
@frameSkipCounter $1
@timerShort $1 @timerShortLow $1
@SRAMBanks $1 ( number of SRAM banks in use )
@isSingleRAMBank $1 ( flag indicating if a single RAM bank is in use )
@loadedRAMBank $1 ( RAM bank currently loaded from disk into memory at $A000 )

( PPU cache to reuse data )
@bgwinMaskedXOffset $1
@bgwinTileDataLow $1
@bgwinTileDataHigh $1

@filepath $40
@default-gb "test_roms/cpu_instrs.gb $1
@savepath $40
@saveExtension "sav $1
@bankPath "_bank @bankPathDigit "A.sav $1

~src/opcodes.tal

(
@|writeHandler )

@write8 ( value addr -- )

  ( General write handlers regardless of MBC )

  ( Quick check for base register writes )
  ( e6 is HIGH(reg8), and all registers must be on the same page )
  ( Note: No measurable performance gains for cpu_instrs test ROM, oddly )
  OVR #e6 NEQ ,&notReg8 JCN STA JMP2r &notReg8

  ( Quick down-select to I/O range )
  OVR #ff NEQ ?MBCHandler

  ( Joypad P1 select )
  DUP #00 NEQ ,&notJoypad JCN
    POP2 ( discard addr )
    #30 AND ( clear old low nibble of rP1 )
    DUP #20 NEQ ,&notAction JCN
      ;joypad LDA #f0 AND ( get high nibble of joypad state )
      #04 SFT ( shift to low nibble )
      ,&doneJoypad JMP
    &notAction
    DUP #10 NEQ ,&notDirection JCN
      ;joypad LDA #0f AND ( get low nibble of joypad state )
      ,&doneJoypad JMP
    &notDirection
      #0f ( everything unpressed )
    &doneJoypad
    ORA ;io/rP1 STA ( set new states, store rP1 )
    JMP2r
  &notJoypad

  ( OAM DMA )
  DUP #46 NEQ ,&notOAMDMA JCN
    POP2 ( discard addr )
    STH ( move high byte to rst )
    #a000 ( copy 160 bytes )
    &oamdmaLoop
      STHkr OVR ( address of byte to copy )
      LDA ( read byte )
      OVR #fe SWP ( OAM address to copy to )
      STA ( write byte )
    INC GTHk ,&oamdmaLoop JCN
    POP2 ( discard loop counters )
    POPr ( discard high byte on rst )
    JMP2r
  &notOAMDMA

  ( DIV reset )
  DUP #04 NEQ ,&notDIV JCN
    POP2 POP ( discard all inputs )
    #0000 ;io/rDIVlow STA2k ( reset entire counter )
    POP2 ;timerShort STA2 ( also reset timerShort duplicate counter )
    JMP2r
  &notDIV

  ( TIMA duplicate write to internal timer tracker )
  DUP #05 NEQ ,&notTIMA JCN
    STAk ( carry out actual write )
    POP2 ( discard target addr )
    ;timerShort STA ( duplicate write to shadow byte, leaving low byte untouched )
    JMP2r
  &notTIMA

  ( IF is a 5 bit register, so always set the top 3 bits )
  DUP #0f NEQ ,&notIF JCN
    ROT #e0 ORA ( set top 3 bits )
    ROT ROT STA ( write )
    JMP2r
  &notIF

  ( fall through into MBC handler )
@MBCHandler $100 ( reserve space for MBC handler to be copied to )

(
@uxnUtility )
@print-state ( -- )
  ;str-BC pstr ;reg8/B LDA print-hex ;reg8/C LDA print-hex
  ;str-DE pstr ;reg8/D LDA print-hex ;reg8/E LDA print-hex
  ;str-HL pstr ;reg8/H LDA print-hex ;reg8/L LDA print-hex
  ;str-AF pstr ;reg8/A LDA print-hex ;reg8/F LDA print-hex
  ;str-SP pstr ;reg8/SPhigh LDA print-hex ;reg8/SPlow LDA print-hex
  ;str-PC pstr ;PC/high LDA print-hex ;PC/low LDA print-hex
  ( ;str-LY ;pstr JSR2 ;io/rLY LDA ;print-hex JSR2
  ;str-dot ;pstr JSR2 ;ppuDot/high LDA ;print-hex JSR2 ;ppuDot/low LDA ;print-hex JSR2
  ;str-stat ;pstr JSR2 ;io/rSTAT LDA ;print-hex JSR2
  ;str-timerShort ;pstr JSR2 ;timerShort LDA ;print-hex JSR2 ;timerShortLow LDA ;print-hex JSR2 ;io/rTIMA LDA ;print-hex JSR2
  ;str-TIMA ;pstr JSR2 ;io/rTIMA LDA ;print-hex JSR2 )
  #0a .Console/write DEO
JMP2r

@str-BC "BC= $1
@str-DE 20 "DE= $1
@str-HL 20 "HL= $1
@str-AF 20 "AF= $1
@str-SP 20 "SP= $1
@str-PC 20 "PC= $1
@str-LY 20 "LY= $1
@str-dot 20 "ppuDot= $1
@str-stat 20 "stat= $1
@str-timerShort 20 "tShort= $1
@str-TIMA 20 20 "@$ff05 20 "= 20 "$ $1

@print-hex ( byte -- )
  DUP
  ( lowercase hex use #27, uppercase: #07 )
  #04 SFT #30 ADD [ #3a LTHk NIP ,&highDigit JCN #07 ADD &highDigit ] .Console/write DEO
  #0f AND #30 ADD [ #3a LTHk NIP ,&lowDigit JCN #07 ADD &lowDigit ] .Console/write DEO
JMP2r


(
@|stdlib )

@scap ( str* -- end* ) LDAk #00 NEQ JMP JMP2r &w INC2 LDAk ,&w JCN JMP2r
@sput ( chr str* -- ) ,scap JSR STA JMP2r
@slen ( str* -- len* ) DUP2 ,scap JSR SWP2 SUB2 JMP2r
@scmp ( a* b* -- f ) STH2 &l LDAk LDAkr STHr ANDk #00 EQU ,&e JCN NEQk ,&e JCN POP2 INC2 INC2r ,&l JMP &e NIP2 POP2r EQU JMP2r
@sclr ( str* -- ) LDAk ,&w JCN POP2 JMP2r &w STH2k #00 STH2r STA INC2 LDAk ,&w JCN POP2 JMP2r
@scpy ( src* dst* -- ) OVR2 LDA ,&e JCN POP2 POP2 JMP2r &e STH2 &w LDAk STH2kr STA INC2r INC2 LDAk ,&w JCN POP2 #00 STH2r STA JMP2r
@skey ( key buf -- proc ) OVR #21 LTH ,&eval JCN #00 SWP ;sput JSR2 #00 JMP2r &eval POP2 #01 JMP2r
@pstr ( str* -- ) &w LDAk #18 DEO INC2 LDAk ,&w JCN POP2 JMP2r

@load-theme ( -- )
    ;theme/path .File0/name DEO2
    #0006 .File0/length DEO2
    ;theme/data .File0/read DEO2
    .File0/success DEI2 #0006 NEQ2 ,&failed JCN
        ( set system colors from loaded theme )
        ;theme/r LDA2 .System/r DEO2
        ;theme/g LDA2 .System/g DEO2
        ;theme/b LDA2 .System/b DEO2
    &failed
    #0000 .File0/name DEO2 ( close file to allow deletion while running )
JMP2r
@theme
    &path ".theme $1
    &data [ &r $2 &g $2 &b $2 ]

( Note: This table is intentionally aligned such that the 41st entry will have a low byte of 0, 
  to help in detecting when it has been filled with 10 entries. There's likely a better way to do
  this, and a way to ensure we don't clobber it by accident. There might even be a sneaky place to
  store it to minimize waste. )
|fcd8 @oamScanTable $29 ( [ xCoord tileHighByte tileLowByte attr ] * 10, plus terminator )

( Note: This must end before fdff to avoid overflowing into Game Boy address space )
